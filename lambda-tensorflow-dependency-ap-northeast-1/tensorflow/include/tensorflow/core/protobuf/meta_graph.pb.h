// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/protobuf/meta_graph.proto

#ifndef PROTOBUF_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto__INCLUDED
#define PROTOBUF_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/map.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
#include "tensorflow/core/framework/graph.pb.h"
#include "tensorflow/core/framework/op_def.pb.h"
#include "tensorflow/core/protobuf/saver.pb.h"
// @@protoc_insertion_point(includes)

namespace tensorflow {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto();
void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto();
void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto();

class CollectionDef;
class CollectionDef_AnyList;
class CollectionDef_BytesList;
class CollectionDef_FloatList;
class CollectionDef_Int64List;
class CollectionDef_NodeList;
class MetaGraphDef;
class MetaGraphDef_MetaInfoDef;

// ===================================================================

class MetaGraphDef_MetaInfoDef : public ::google::protobuf::Message {
 public:
  MetaGraphDef_MetaInfoDef();
  virtual ~MetaGraphDef_MetaInfoDef();

  MetaGraphDef_MetaInfoDef(const MetaGraphDef_MetaInfoDef& from);

  inline MetaGraphDef_MetaInfoDef& operator=(const MetaGraphDef_MetaInfoDef& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MetaGraphDef_MetaInfoDef& default_instance();

  void Swap(MetaGraphDef_MetaInfoDef* other);

  // implements Message ----------------------------------------------

  inline MetaGraphDef_MetaInfoDef* New() const { return New(NULL); }

  MetaGraphDef_MetaInfoDef* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MetaGraphDef_MetaInfoDef& from);
  void MergeFrom(const MetaGraphDef_MetaInfoDef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MetaGraphDef_MetaInfoDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string meta_graph_version = 1;
  void clear_meta_graph_version();
  static const int kMetaGraphVersionFieldNumber = 1;
  const ::std::string& meta_graph_version() const;
  void set_meta_graph_version(const ::std::string& value);
  void set_meta_graph_version(const char* value);
  void set_meta_graph_version(const char* value, size_t size);
  ::std::string* mutable_meta_graph_version();
  ::std::string* release_meta_graph_version();
  void set_allocated_meta_graph_version(::std::string* meta_graph_version);

  // optional .tensorflow.OpList stripped_op_list = 2;
  bool has_stripped_op_list() const;
  void clear_stripped_op_list();
  static const int kStrippedOpListFieldNumber = 2;
  const ::tensorflow::OpList& stripped_op_list() const;
  ::tensorflow::OpList* mutable_stripped_op_list();
  ::tensorflow::OpList* release_stripped_op_list();
  void set_allocated_stripped_op_list(::tensorflow::OpList* stripped_op_list);

  // optional .google.protobuf.Any any_info = 3;
  bool has_any_info() const;
  void clear_any_info();
  static const int kAnyInfoFieldNumber = 3;
  const ::google::protobuf::Any& any_info() const;
  ::google::protobuf::Any* mutable_any_info();
  ::google::protobuf::Any* release_any_info();
  void set_allocated_any_info(::google::protobuf::Any* any_info);

  // @@protoc_insertion_point(class_scope:tensorflow.MetaGraphDef.MetaInfoDef)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr meta_graph_version_;
  ::tensorflow::OpList* stripped_op_list_;
  ::google::protobuf::Any* any_info_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto();

  void InitAsDefaultInstance();
  static MetaGraphDef_MetaInfoDef* default_instance_;
};
// -------------------------------------------------------------------

class MetaGraphDef : public ::google::protobuf::Message {
 public:
  MetaGraphDef();
  virtual ~MetaGraphDef();

  MetaGraphDef(const MetaGraphDef& from);

  inline MetaGraphDef& operator=(const MetaGraphDef& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MetaGraphDef& default_instance();

  void Swap(MetaGraphDef* other);

  // implements Message ----------------------------------------------

  inline MetaGraphDef* New() const { return New(NULL); }

  MetaGraphDef* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MetaGraphDef& from);
  void MergeFrom(const MetaGraphDef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MetaGraphDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MetaGraphDef_MetaInfoDef MetaInfoDef;

  // accessors -------------------------------------------------------

  // optional .tensorflow.MetaGraphDef.MetaInfoDef meta_info_def = 1;
  bool has_meta_info_def() const;
  void clear_meta_info_def();
  static const int kMetaInfoDefFieldNumber = 1;
  const ::tensorflow::MetaGraphDef_MetaInfoDef& meta_info_def() const;
  ::tensorflow::MetaGraphDef_MetaInfoDef* mutable_meta_info_def();
  ::tensorflow::MetaGraphDef_MetaInfoDef* release_meta_info_def();
  void set_allocated_meta_info_def(::tensorflow::MetaGraphDef_MetaInfoDef* meta_info_def);

  // optional .tensorflow.GraphDef graph_def = 2;
  bool has_graph_def() const;
  void clear_graph_def();
  static const int kGraphDefFieldNumber = 2;
  const ::tensorflow::GraphDef& graph_def() const;
  ::tensorflow::GraphDef* mutable_graph_def();
  ::tensorflow::GraphDef* release_graph_def();
  void set_allocated_graph_def(::tensorflow::GraphDef* graph_def);

  // optional .tensorflow.SaverDef saver_def = 3;
  bool has_saver_def() const;
  void clear_saver_def();
  static const int kSaverDefFieldNumber = 3;
  const ::tensorflow::SaverDef& saver_def() const;
  ::tensorflow::SaverDef* mutable_saver_def();
  ::tensorflow::SaverDef* release_saver_def();
  void set_allocated_saver_def(::tensorflow::SaverDef* saver_def);

  // map<string, .tensorflow.CollectionDef> collection_def = 4;
  int collection_def_size() const;
  void clear_collection_def();
  static const int kCollectionDefFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, ::tensorflow::CollectionDef >&
      collection_def() const;
  ::google::protobuf::Map< ::std::string, ::tensorflow::CollectionDef >*
      mutable_collection_def();

  // @@protoc_insertion_point(class_scope:tensorflow.MetaGraphDef)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::tensorflow::MetaGraphDef_MetaInfoDef* meta_info_def_;
  ::tensorflow::GraphDef* graph_def_;
  ::tensorflow::SaverDef* saver_def_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::tensorflow::CollectionDef,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      MetaGraphDef_CollectionDefEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, ::tensorflow::CollectionDef,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > collection_def_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto();

  void InitAsDefaultInstance();
  static MetaGraphDef* default_instance_;
};
// -------------------------------------------------------------------

class CollectionDef_NodeList : public ::google::protobuf::Message {
 public:
  CollectionDef_NodeList();
  virtual ~CollectionDef_NodeList();

  CollectionDef_NodeList(const CollectionDef_NodeList& from);

  inline CollectionDef_NodeList& operator=(const CollectionDef_NodeList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CollectionDef_NodeList& default_instance();

  void Swap(CollectionDef_NodeList* other);

  // implements Message ----------------------------------------------

  inline CollectionDef_NodeList* New() const { return New(NULL); }

  CollectionDef_NodeList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CollectionDef_NodeList& from);
  void MergeFrom(const CollectionDef_NodeList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CollectionDef_NodeList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string value = 1;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value(int index) const;
  ::std::string* mutable_value(int index);
  void set_value(int index, const ::std::string& value);
  void set_value(int index, const char* value);
  void set_value(int index, const char* value, size_t size);
  ::std::string* add_value();
  void add_value(const ::std::string& value);
  void add_value(const char* value);
  void add_value(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& value() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_value();

  // @@protoc_insertion_point(class_scope:tensorflow.CollectionDef.NodeList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::std::string> value_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto();

  void InitAsDefaultInstance();
  static CollectionDef_NodeList* default_instance_;
};
// -------------------------------------------------------------------

class CollectionDef_BytesList : public ::google::protobuf::Message {
 public:
  CollectionDef_BytesList();
  virtual ~CollectionDef_BytesList();

  CollectionDef_BytesList(const CollectionDef_BytesList& from);

  inline CollectionDef_BytesList& operator=(const CollectionDef_BytesList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CollectionDef_BytesList& default_instance();

  void Swap(CollectionDef_BytesList* other);

  // implements Message ----------------------------------------------

  inline CollectionDef_BytesList* New() const { return New(NULL); }

  CollectionDef_BytesList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CollectionDef_BytesList& from);
  void MergeFrom(const CollectionDef_BytesList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CollectionDef_BytesList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes value = 1;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value(int index) const;
  ::std::string* mutable_value(int index);
  void set_value(int index, const ::std::string& value);
  void set_value(int index, const char* value);
  void set_value(int index, const void* value, size_t size);
  ::std::string* add_value();
  void add_value(const ::std::string& value);
  void add_value(const char* value);
  void add_value(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& value() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_value();

  // @@protoc_insertion_point(class_scope:tensorflow.CollectionDef.BytesList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::std::string> value_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto();

  void InitAsDefaultInstance();
  static CollectionDef_BytesList* default_instance_;
};
// -------------------------------------------------------------------

class CollectionDef_Int64List : public ::google::protobuf::Message {
 public:
  CollectionDef_Int64List();
  virtual ~CollectionDef_Int64List();

  CollectionDef_Int64List(const CollectionDef_Int64List& from);

  inline CollectionDef_Int64List& operator=(const CollectionDef_Int64List& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CollectionDef_Int64List& default_instance();

  void Swap(CollectionDef_Int64List* other);

  // implements Message ----------------------------------------------

  inline CollectionDef_Int64List* New() const { return New(NULL); }

  CollectionDef_Int64List* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CollectionDef_Int64List& from);
  void MergeFrom(const CollectionDef_Int64List& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CollectionDef_Int64List* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 value = 1 [packed = true];
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::int64 value(int index) const;
  void set_value(int index, ::google::protobuf::int64 value);
  void add_value(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      value() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:tensorflow.CollectionDef.Int64List)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > value_;
  mutable int _value_cached_byte_size_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto();

  void InitAsDefaultInstance();
  static CollectionDef_Int64List* default_instance_;
};
// -------------------------------------------------------------------

class CollectionDef_FloatList : public ::google::protobuf::Message {
 public:
  CollectionDef_FloatList();
  virtual ~CollectionDef_FloatList();

  CollectionDef_FloatList(const CollectionDef_FloatList& from);

  inline CollectionDef_FloatList& operator=(const CollectionDef_FloatList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CollectionDef_FloatList& default_instance();

  void Swap(CollectionDef_FloatList* other);

  // implements Message ----------------------------------------------

  inline CollectionDef_FloatList* New() const { return New(NULL); }

  CollectionDef_FloatList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CollectionDef_FloatList& from);
  void MergeFrom(const CollectionDef_FloatList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CollectionDef_FloatList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float value = 1 [packed = true];
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  float value(int index) const;
  void set_value(int index, float value);
  void add_value(float value);
  const ::google::protobuf::RepeatedField< float >&
      value() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:tensorflow.CollectionDef.FloatList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedField< float > value_;
  mutable int _value_cached_byte_size_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto();

  void InitAsDefaultInstance();
  static CollectionDef_FloatList* default_instance_;
};
// -------------------------------------------------------------------

class CollectionDef_AnyList : public ::google::protobuf::Message {
 public:
  CollectionDef_AnyList();
  virtual ~CollectionDef_AnyList();

  CollectionDef_AnyList(const CollectionDef_AnyList& from);

  inline CollectionDef_AnyList& operator=(const CollectionDef_AnyList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CollectionDef_AnyList& default_instance();

  void Swap(CollectionDef_AnyList* other);

  // implements Message ----------------------------------------------

  inline CollectionDef_AnyList* New() const { return New(NULL); }

  CollectionDef_AnyList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CollectionDef_AnyList& from);
  void MergeFrom(const CollectionDef_AnyList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CollectionDef_AnyList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .google.protobuf.Any value = 1;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::google::protobuf::Any& value(int index) const;
  ::google::protobuf::Any* mutable_value(int index);
  ::google::protobuf::Any* add_value();
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_value();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
      value() const;

  // @@protoc_insertion_point(class_scope:tensorflow.CollectionDef.AnyList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > value_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto();

  void InitAsDefaultInstance();
  static CollectionDef_AnyList* default_instance_;
};
// -------------------------------------------------------------------

class CollectionDef : public ::google::protobuf::Message {
 public:
  CollectionDef();
  virtual ~CollectionDef();

  CollectionDef(const CollectionDef& from);

  inline CollectionDef& operator=(const CollectionDef& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CollectionDef& default_instance();

  enum KindCase {
    kNodeList = 1,
    kBytesList = 2,
    kInt64List = 3,
    kFloatList = 4,
    kAnyList = 5,
    KIND_NOT_SET = 0,
  };

  void Swap(CollectionDef* other);

  // implements Message ----------------------------------------------

  inline CollectionDef* New() const { return New(NULL); }

  CollectionDef* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CollectionDef& from);
  void MergeFrom(const CollectionDef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CollectionDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CollectionDef_NodeList NodeList;
  typedef CollectionDef_BytesList BytesList;
  typedef CollectionDef_Int64List Int64List;
  typedef CollectionDef_FloatList FloatList;
  typedef CollectionDef_AnyList AnyList;

  // accessors -------------------------------------------------------

  // optional .tensorflow.CollectionDef.NodeList node_list = 1;
  bool has_node_list() const;
  void clear_node_list();
  static const int kNodeListFieldNumber = 1;
  const ::tensorflow::CollectionDef_NodeList& node_list() const;
  ::tensorflow::CollectionDef_NodeList* mutable_node_list();
  ::tensorflow::CollectionDef_NodeList* release_node_list();
  void set_allocated_node_list(::tensorflow::CollectionDef_NodeList* node_list);

  // optional .tensorflow.CollectionDef.BytesList bytes_list = 2;
  bool has_bytes_list() const;
  void clear_bytes_list();
  static const int kBytesListFieldNumber = 2;
  const ::tensorflow::CollectionDef_BytesList& bytes_list() const;
  ::tensorflow::CollectionDef_BytesList* mutable_bytes_list();
  ::tensorflow::CollectionDef_BytesList* release_bytes_list();
  void set_allocated_bytes_list(::tensorflow::CollectionDef_BytesList* bytes_list);

  // optional .tensorflow.CollectionDef.Int64List int64_list = 3;
  bool has_int64_list() const;
  void clear_int64_list();
  static const int kInt64ListFieldNumber = 3;
  const ::tensorflow::CollectionDef_Int64List& int64_list() const;
  ::tensorflow::CollectionDef_Int64List* mutable_int64_list();
  ::tensorflow::CollectionDef_Int64List* release_int64_list();
  void set_allocated_int64_list(::tensorflow::CollectionDef_Int64List* int64_list);

  // optional .tensorflow.CollectionDef.FloatList float_list = 4;
  bool has_float_list() const;
  void clear_float_list();
  static const int kFloatListFieldNumber = 4;
  const ::tensorflow::CollectionDef_FloatList& float_list() const;
  ::tensorflow::CollectionDef_FloatList* mutable_float_list();
  ::tensorflow::CollectionDef_FloatList* release_float_list();
  void set_allocated_float_list(::tensorflow::CollectionDef_FloatList* float_list);

  // optional .tensorflow.CollectionDef.AnyList any_list = 5;
  bool has_any_list() const;
  void clear_any_list();
  static const int kAnyListFieldNumber = 5;
  const ::tensorflow::CollectionDef_AnyList& any_list() const;
  ::tensorflow::CollectionDef_AnyList* mutable_any_list();
  ::tensorflow::CollectionDef_AnyList* release_any_list();
  void set_allocated_any_list(::tensorflow::CollectionDef_AnyList* any_list);

  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.CollectionDef)
 private:
  inline void set_has_node_list();
  inline void set_has_bytes_list();
  inline void set_has_int64_list();
  inline void set_has_float_list();
  inline void set_has_any_list();

  inline bool has_kind() const;
  void clear_kind();
  inline void clear_has_kind();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union KindUnion {
    KindUnion() {}
    ::tensorflow::CollectionDef_NodeList* node_list_;
    ::tensorflow::CollectionDef_BytesList* bytes_list_;
    ::tensorflow::CollectionDef_Int64List* int64_list_;
    ::tensorflow::CollectionDef_FloatList* float_list_;
    ::tensorflow::CollectionDef_AnyList* any_list_;
  } kind_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto();

  void InitAsDefaultInstance();
  static CollectionDef* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// MetaGraphDef_MetaInfoDef

// optional string meta_graph_version = 1;
inline void MetaGraphDef_MetaInfoDef::clear_meta_graph_version() {
  meta_graph_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MetaGraphDef_MetaInfoDef::meta_graph_version() const {
  // @@protoc_insertion_point(field_get:tensorflow.MetaGraphDef.MetaInfoDef.meta_graph_version)
  return meta_graph_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MetaGraphDef_MetaInfoDef::set_meta_graph_version(const ::std::string& value) {
  
  meta_graph_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.MetaGraphDef.MetaInfoDef.meta_graph_version)
}
inline void MetaGraphDef_MetaInfoDef::set_meta_graph_version(const char* value) {
  
  meta_graph_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.MetaGraphDef.MetaInfoDef.meta_graph_version)
}
inline void MetaGraphDef_MetaInfoDef::set_meta_graph_version(const char* value, size_t size) {
  
  meta_graph_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.MetaGraphDef.MetaInfoDef.meta_graph_version)
}
inline ::std::string* MetaGraphDef_MetaInfoDef::mutable_meta_graph_version() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.MetaGraphDef.MetaInfoDef.meta_graph_version)
  return meta_graph_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MetaGraphDef_MetaInfoDef::release_meta_graph_version() {
  // @@protoc_insertion_point(field_release:tensorflow.MetaGraphDef.MetaInfoDef.meta_graph_version)
  
  return meta_graph_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MetaGraphDef_MetaInfoDef::set_allocated_meta_graph_version(::std::string* meta_graph_version) {
  if (meta_graph_version != NULL) {
    
  } else {
    
  }
  meta_graph_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), meta_graph_version);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MetaGraphDef.MetaInfoDef.meta_graph_version)
}

// optional .tensorflow.OpList stripped_op_list = 2;
inline bool MetaGraphDef_MetaInfoDef::has_stripped_op_list() const {
  return !_is_default_instance_ && stripped_op_list_ != NULL;
}
inline void MetaGraphDef_MetaInfoDef::clear_stripped_op_list() {
  if (GetArenaNoVirtual() == NULL && stripped_op_list_ != NULL) delete stripped_op_list_;
  stripped_op_list_ = NULL;
}
inline const ::tensorflow::OpList& MetaGraphDef_MetaInfoDef::stripped_op_list() const {
  // @@protoc_insertion_point(field_get:tensorflow.MetaGraphDef.MetaInfoDef.stripped_op_list)
  return stripped_op_list_ != NULL ? *stripped_op_list_ : *default_instance_->stripped_op_list_;
}
inline ::tensorflow::OpList* MetaGraphDef_MetaInfoDef::mutable_stripped_op_list() {
  
  if (stripped_op_list_ == NULL) {
    stripped_op_list_ = new ::tensorflow::OpList;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.MetaGraphDef.MetaInfoDef.stripped_op_list)
  return stripped_op_list_;
}
inline ::tensorflow::OpList* MetaGraphDef_MetaInfoDef::release_stripped_op_list() {
  // @@protoc_insertion_point(field_release:tensorflow.MetaGraphDef.MetaInfoDef.stripped_op_list)
  
  ::tensorflow::OpList* temp = stripped_op_list_;
  stripped_op_list_ = NULL;
  return temp;
}
inline void MetaGraphDef_MetaInfoDef::set_allocated_stripped_op_list(::tensorflow::OpList* stripped_op_list) {
  delete stripped_op_list_;
  stripped_op_list_ = stripped_op_list;
  if (stripped_op_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MetaGraphDef.MetaInfoDef.stripped_op_list)
}

// optional .google.protobuf.Any any_info = 3;
inline bool MetaGraphDef_MetaInfoDef::has_any_info() const {
  return !_is_default_instance_ && any_info_ != NULL;
}
inline void MetaGraphDef_MetaInfoDef::clear_any_info() {
  if (GetArenaNoVirtual() == NULL && any_info_ != NULL) delete any_info_;
  any_info_ = NULL;
}
inline const ::google::protobuf::Any& MetaGraphDef_MetaInfoDef::any_info() const {
  // @@protoc_insertion_point(field_get:tensorflow.MetaGraphDef.MetaInfoDef.any_info)
  return any_info_ != NULL ? *any_info_ : *default_instance_->any_info_;
}
inline ::google::protobuf::Any* MetaGraphDef_MetaInfoDef::mutable_any_info() {
  
  if (any_info_ == NULL) {
    any_info_ = new ::google::protobuf::Any;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.MetaGraphDef.MetaInfoDef.any_info)
  return any_info_;
}
inline ::google::protobuf::Any* MetaGraphDef_MetaInfoDef::release_any_info() {
  // @@protoc_insertion_point(field_release:tensorflow.MetaGraphDef.MetaInfoDef.any_info)
  
  ::google::protobuf::Any* temp = any_info_;
  any_info_ = NULL;
  return temp;
}
inline void MetaGraphDef_MetaInfoDef::set_allocated_any_info(::google::protobuf::Any* any_info) {
  delete any_info_;
  any_info_ = any_info;
  if (any_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MetaGraphDef.MetaInfoDef.any_info)
}

// -------------------------------------------------------------------

// MetaGraphDef

// optional .tensorflow.MetaGraphDef.MetaInfoDef meta_info_def = 1;
inline bool MetaGraphDef::has_meta_info_def() const {
  return !_is_default_instance_ && meta_info_def_ != NULL;
}
inline void MetaGraphDef::clear_meta_info_def() {
  if (GetArenaNoVirtual() == NULL && meta_info_def_ != NULL) delete meta_info_def_;
  meta_info_def_ = NULL;
}
inline const ::tensorflow::MetaGraphDef_MetaInfoDef& MetaGraphDef::meta_info_def() const {
  // @@protoc_insertion_point(field_get:tensorflow.MetaGraphDef.meta_info_def)
  return meta_info_def_ != NULL ? *meta_info_def_ : *default_instance_->meta_info_def_;
}
inline ::tensorflow::MetaGraphDef_MetaInfoDef* MetaGraphDef::mutable_meta_info_def() {
  
  if (meta_info_def_ == NULL) {
    meta_info_def_ = new ::tensorflow::MetaGraphDef_MetaInfoDef;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.MetaGraphDef.meta_info_def)
  return meta_info_def_;
}
inline ::tensorflow::MetaGraphDef_MetaInfoDef* MetaGraphDef::release_meta_info_def() {
  // @@protoc_insertion_point(field_release:tensorflow.MetaGraphDef.meta_info_def)
  
  ::tensorflow::MetaGraphDef_MetaInfoDef* temp = meta_info_def_;
  meta_info_def_ = NULL;
  return temp;
}
inline void MetaGraphDef::set_allocated_meta_info_def(::tensorflow::MetaGraphDef_MetaInfoDef* meta_info_def) {
  delete meta_info_def_;
  meta_info_def_ = meta_info_def;
  if (meta_info_def) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MetaGraphDef.meta_info_def)
}

// optional .tensorflow.GraphDef graph_def = 2;
inline bool MetaGraphDef::has_graph_def() const {
  return !_is_default_instance_ && graph_def_ != NULL;
}
inline void MetaGraphDef::clear_graph_def() {
  if (GetArenaNoVirtual() == NULL && graph_def_ != NULL) delete graph_def_;
  graph_def_ = NULL;
}
inline const ::tensorflow::GraphDef& MetaGraphDef::graph_def() const {
  // @@protoc_insertion_point(field_get:tensorflow.MetaGraphDef.graph_def)
  return graph_def_ != NULL ? *graph_def_ : *default_instance_->graph_def_;
}
inline ::tensorflow::GraphDef* MetaGraphDef::mutable_graph_def() {
  
  if (graph_def_ == NULL) {
    graph_def_ = new ::tensorflow::GraphDef;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.MetaGraphDef.graph_def)
  return graph_def_;
}
inline ::tensorflow::GraphDef* MetaGraphDef::release_graph_def() {
  // @@protoc_insertion_point(field_release:tensorflow.MetaGraphDef.graph_def)
  
  ::tensorflow::GraphDef* temp = graph_def_;
  graph_def_ = NULL;
  return temp;
}
inline void MetaGraphDef::set_allocated_graph_def(::tensorflow::GraphDef* graph_def) {
  delete graph_def_;
  graph_def_ = graph_def;
  if (graph_def) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MetaGraphDef.graph_def)
}

// optional .tensorflow.SaverDef saver_def = 3;
inline bool MetaGraphDef::has_saver_def() const {
  return !_is_default_instance_ && saver_def_ != NULL;
}
inline void MetaGraphDef::clear_saver_def() {
  if (GetArenaNoVirtual() == NULL && saver_def_ != NULL) delete saver_def_;
  saver_def_ = NULL;
}
inline const ::tensorflow::SaverDef& MetaGraphDef::saver_def() const {
  // @@protoc_insertion_point(field_get:tensorflow.MetaGraphDef.saver_def)
  return saver_def_ != NULL ? *saver_def_ : *default_instance_->saver_def_;
}
inline ::tensorflow::SaverDef* MetaGraphDef::mutable_saver_def() {
  
  if (saver_def_ == NULL) {
    saver_def_ = new ::tensorflow::SaverDef;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.MetaGraphDef.saver_def)
  return saver_def_;
}
inline ::tensorflow::SaverDef* MetaGraphDef::release_saver_def() {
  // @@protoc_insertion_point(field_release:tensorflow.MetaGraphDef.saver_def)
  
  ::tensorflow::SaverDef* temp = saver_def_;
  saver_def_ = NULL;
  return temp;
}
inline void MetaGraphDef::set_allocated_saver_def(::tensorflow::SaverDef* saver_def) {
  delete saver_def_;
  saver_def_ = saver_def;
  if (saver_def) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MetaGraphDef.saver_def)
}

// map<string, .tensorflow.CollectionDef> collection_def = 4;
inline int MetaGraphDef::collection_def_size() const {
  return collection_def_.size();
}
inline void MetaGraphDef::clear_collection_def() {
  collection_def_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::tensorflow::CollectionDef >&
MetaGraphDef::collection_def() const {
  // @@protoc_insertion_point(field_map:tensorflow.MetaGraphDef.collection_def)
  return collection_def_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::tensorflow::CollectionDef >*
MetaGraphDef::mutable_collection_def() {
  // @@protoc_insertion_point(field_mutable_map:tensorflow.MetaGraphDef.collection_def)
  return collection_def_.MutableMap();
}

// -------------------------------------------------------------------

// CollectionDef_NodeList

// repeated string value = 1;
inline int CollectionDef_NodeList::value_size() const {
  return value_.size();
}
inline void CollectionDef_NodeList::clear_value() {
  value_.Clear();
}
inline const ::std::string& CollectionDef_NodeList::value(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.CollectionDef.NodeList.value)
  return value_.Get(index);
}
inline ::std::string* CollectionDef_NodeList::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.CollectionDef.NodeList.value)
  return value_.Mutable(index);
}
inline void CollectionDef_NodeList::set_value(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.CollectionDef.NodeList.value)
  value_.Mutable(index)->assign(value);
}
inline void CollectionDef_NodeList::set_value(int index, const char* value) {
  value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.CollectionDef.NodeList.value)
}
inline void CollectionDef_NodeList::set_value(int index, const char* value, size_t size) {
  value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.CollectionDef.NodeList.value)
}
inline ::std::string* CollectionDef_NodeList::add_value() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.CollectionDef.NodeList.value)
  return value_.Add();
}
inline void CollectionDef_NodeList::add_value(const ::std::string& value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.CollectionDef.NodeList.value)
}
inline void CollectionDef_NodeList::add_value(const char* value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.CollectionDef.NodeList.value)
}
inline void CollectionDef_NodeList::add_value(const char* value, size_t size) {
  value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.CollectionDef.NodeList.value)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CollectionDef_NodeList::value() const {
  // @@protoc_insertion_point(field_list:tensorflow.CollectionDef.NodeList.value)
  return value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CollectionDef_NodeList::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.CollectionDef.NodeList.value)
  return &value_;
}

// -------------------------------------------------------------------

// CollectionDef_BytesList

// repeated bytes value = 1;
inline int CollectionDef_BytesList::value_size() const {
  return value_.size();
}
inline void CollectionDef_BytesList::clear_value() {
  value_.Clear();
}
inline const ::std::string& CollectionDef_BytesList::value(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.CollectionDef.BytesList.value)
  return value_.Get(index);
}
inline ::std::string* CollectionDef_BytesList::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.CollectionDef.BytesList.value)
  return value_.Mutable(index);
}
inline void CollectionDef_BytesList::set_value(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.CollectionDef.BytesList.value)
  value_.Mutable(index)->assign(value);
}
inline void CollectionDef_BytesList::set_value(int index, const char* value) {
  value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.CollectionDef.BytesList.value)
}
inline void CollectionDef_BytesList::set_value(int index, const void* value, size_t size) {
  value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.CollectionDef.BytesList.value)
}
inline ::std::string* CollectionDef_BytesList::add_value() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.CollectionDef.BytesList.value)
  return value_.Add();
}
inline void CollectionDef_BytesList::add_value(const ::std::string& value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.CollectionDef.BytesList.value)
}
inline void CollectionDef_BytesList::add_value(const char* value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.CollectionDef.BytesList.value)
}
inline void CollectionDef_BytesList::add_value(const void* value, size_t size) {
  value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.CollectionDef.BytesList.value)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CollectionDef_BytesList::value() const {
  // @@protoc_insertion_point(field_list:tensorflow.CollectionDef.BytesList.value)
  return value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CollectionDef_BytesList::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.CollectionDef.BytesList.value)
  return &value_;
}

// -------------------------------------------------------------------

// CollectionDef_Int64List

// repeated int64 value = 1 [packed = true];
inline int CollectionDef_Int64List::value_size() const {
  return value_.size();
}
inline void CollectionDef_Int64List::clear_value() {
  value_.Clear();
}
inline ::google::protobuf::int64 CollectionDef_Int64List::value(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.CollectionDef.Int64List.value)
  return value_.Get(index);
}
inline void CollectionDef_Int64List::set_value(int index, ::google::protobuf::int64 value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.CollectionDef.Int64List.value)
}
inline void CollectionDef_Int64List::add_value(::google::protobuf::int64 value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.CollectionDef.Int64List.value)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
CollectionDef_Int64List::value() const {
  // @@protoc_insertion_point(field_list:tensorflow.CollectionDef.Int64List.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
CollectionDef_Int64List::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.CollectionDef.Int64List.value)
  return &value_;
}

// -------------------------------------------------------------------

// CollectionDef_FloatList

// repeated float value = 1 [packed = true];
inline int CollectionDef_FloatList::value_size() const {
  return value_.size();
}
inline void CollectionDef_FloatList::clear_value() {
  value_.Clear();
}
inline float CollectionDef_FloatList::value(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.CollectionDef.FloatList.value)
  return value_.Get(index);
}
inline void CollectionDef_FloatList::set_value(int index, float value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.CollectionDef.FloatList.value)
}
inline void CollectionDef_FloatList::add_value(float value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.CollectionDef.FloatList.value)
}
inline const ::google::protobuf::RepeatedField< float >&
CollectionDef_FloatList::value() const {
  // @@protoc_insertion_point(field_list:tensorflow.CollectionDef.FloatList.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< float >*
CollectionDef_FloatList::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.CollectionDef.FloatList.value)
  return &value_;
}

// -------------------------------------------------------------------

// CollectionDef_AnyList

// repeated .google.protobuf.Any value = 1;
inline int CollectionDef_AnyList::value_size() const {
  return value_.size();
}
inline void CollectionDef_AnyList::clear_value() {
  value_.Clear();
}
inline const ::google::protobuf::Any& CollectionDef_AnyList::value(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.CollectionDef.AnyList.value)
  return value_.Get(index);
}
inline ::google::protobuf::Any* CollectionDef_AnyList::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.CollectionDef.AnyList.value)
  return value_.Mutable(index);
}
inline ::google::protobuf::Any* CollectionDef_AnyList::add_value() {
  // @@protoc_insertion_point(field_add:tensorflow.CollectionDef.AnyList.value)
  return value_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
CollectionDef_AnyList::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.CollectionDef.AnyList.value)
  return &value_;
}
inline const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
CollectionDef_AnyList::value() const {
  // @@protoc_insertion_point(field_list:tensorflow.CollectionDef.AnyList.value)
  return value_;
}

// -------------------------------------------------------------------

// CollectionDef

// optional .tensorflow.CollectionDef.NodeList node_list = 1;
inline bool CollectionDef::has_node_list() const {
  return kind_case() == kNodeList;
}
inline void CollectionDef::set_has_node_list() {
  _oneof_case_[0] = kNodeList;
}
inline void CollectionDef::clear_node_list() {
  if (has_node_list()) {
    delete kind_.node_list_;
    clear_has_kind();
  }
}
inline  const ::tensorflow::CollectionDef_NodeList& CollectionDef::node_list() const {
  // @@protoc_insertion_point(field_get:tensorflow.CollectionDef.node_list)
  return has_node_list()
      ? *kind_.node_list_
      : ::tensorflow::CollectionDef_NodeList::default_instance();
}
inline ::tensorflow::CollectionDef_NodeList* CollectionDef::mutable_node_list() {
  if (!has_node_list()) {
    clear_kind();
    set_has_node_list();
    kind_.node_list_ = new ::tensorflow::CollectionDef_NodeList;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.CollectionDef.node_list)
  return kind_.node_list_;
}
inline ::tensorflow::CollectionDef_NodeList* CollectionDef::release_node_list() {
  // @@protoc_insertion_point(field_release:tensorflow.CollectionDef.node_list)
  if (has_node_list()) {
    clear_has_kind();
    ::tensorflow::CollectionDef_NodeList* temp = kind_.node_list_;
    kind_.node_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CollectionDef::set_allocated_node_list(::tensorflow::CollectionDef_NodeList* node_list) {
  clear_kind();
  if (node_list) {
    set_has_node_list();
    kind_.node_list_ = node_list;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CollectionDef.node_list)
}

// optional .tensorflow.CollectionDef.BytesList bytes_list = 2;
inline bool CollectionDef::has_bytes_list() const {
  return kind_case() == kBytesList;
}
inline void CollectionDef::set_has_bytes_list() {
  _oneof_case_[0] = kBytesList;
}
inline void CollectionDef::clear_bytes_list() {
  if (has_bytes_list()) {
    delete kind_.bytes_list_;
    clear_has_kind();
  }
}
inline  const ::tensorflow::CollectionDef_BytesList& CollectionDef::bytes_list() const {
  // @@protoc_insertion_point(field_get:tensorflow.CollectionDef.bytes_list)
  return has_bytes_list()
      ? *kind_.bytes_list_
      : ::tensorflow::CollectionDef_BytesList::default_instance();
}
inline ::tensorflow::CollectionDef_BytesList* CollectionDef::mutable_bytes_list() {
  if (!has_bytes_list()) {
    clear_kind();
    set_has_bytes_list();
    kind_.bytes_list_ = new ::tensorflow::CollectionDef_BytesList;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.CollectionDef.bytes_list)
  return kind_.bytes_list_;
}
inline ::tensorflow::CollectionDef_BytesList* CollectionDef::release_bytes_list() {
  // @@protoc_insertion_point(field_release:tensorflow.CollectionDef.bytes_list)
  if (has_bytes_list()) {
    clear_has_kind();
    ::tensorflow::CollectionDef_BytesList* temp = kind_.bytes_list_;
    kind_.bytes_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CollectionDef::set_allocated_bytes_list(::tensorflow::CollectionDef_BytesList* bytes_list) {
  clear_kind();
  if (bytes_list) {
    set_has_bytes_list();
    kind_.bytes_list_ = bytes_list;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CollectionDef.bytes_list)
}

// optional .tensorflow.CollectionDef.Int64List int64_list = 3;
inline bool CollectionDef::has_int64_list() const {
  return kind_case() == kInt64List;
}
inline void CollectionDef::set_has_int64_list() {
  _oneof_case_[0] = kInt64List;
}
inline void CollectionDef::clear_int64_list() {
  if (has_int64_list()) {
    delete kind_.int64_list_;
    clear_has_kind();
  }
}
inline  const ::tensorflow::CollectionDef_Int64List& CollectionDef::int64_list() const {
  // @@protoc_insertion_point(field_get:tensorflow.CollectionDef.int64_list)
  return has_int64_list()
      ? *kind_.int64_list_
      : ::tensorflow::CollectionDef_Int64List::default_instance();
}
inline ::tensorflow::CollectionDef_Int64List* CollectionDef::mutable_int64_list() {
  if (!has_int64_list()) {
    clear_kind();
    set_has_int64_list();
    kind_.int64_list_ = new ::tensorflow::CollectionDef_Int64List;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.CollectionDef.int64_list)
  return kind_.int64_list_;
}
inline ::tensorflow::CollectionDef_Int64List* CollectionDef::release_int64_list() {
  // @@protoc_insertion_point(field_release:tensorflow.CollectionDef.int64_list)
  if (has_int64_list()) {
    clear_has_kind();
    ::tensorflow::CollectionDef_Int64List* temp = kind_.int64_list_;
    kind_.int64_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CollectionDef::set_allocated_int64_list(::tensorflow::CollectionDef_Int64List* int64_list) {
  clear_kind();
  if (int64_list) {
    set_has_int64_list();
    kind_.int64_list_ = int64_list;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CollectionDef.int64_list)
}

// optional .tensorflow.CollectionDef.FloatList float_list = 4;
inline bool CollectionDef::has_float_list() const {
  return kind_case() == kFloatList;
}
inline void CollectionDef::set_has_float_list() {
  _oneof_case_[0] = kFloatList;
}
inline void CollectionDef::clear_float_list() {
  if (has_float_list()) {
    delete kind_.float_list_;
    clear_has_kind();
  }
}
inline  const ::tensorflow::CollectionDef_FloatList& CollectionDef::float_list() const {
  // @@protoc_insertion_point(field_get:tensorflow.CollectionDef.float_list)
  return has_float_list()
      ? *kind_.float_list_
      : ::tensorflow::CollectionDef_FloatList::default_instance();
}
inline ::tensorflow::CollectionDef_FloatList* CollectionDef::mutable_float_list() {
  if (!has_float_list()) {
    clear_kind();
    set_has_float_list();
    kind_.float_list_ = new ::tensorflow::CollectionDef_FloatList;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.CollectionDef.float_list)
  return kind_.float_list_;
}
inline ::tensorflow::CollectionDef_FloatList* CollectionDef::release_float_list() {
  // @@protoc_insertion_point(field_release:tensorflow.CollectionDef.float_list)
  if (has_float_list()) {
    clear_has_kind();
    ::tensorflow::CollectionDef_FloatList* temp = kind_.float_list_;
    kind_.float_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CollectionDef::set_allocated_float_list(::tensorflow::CollectionDef_FloatList* float_list) {
  clear_kind();
  if (float_list) {
    set_has_float_list();
    kind_.float_list_ = float_list;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CollectionDef.float_list)
}

// optional .tensorflow.CollectionDef.AnyList any_list = 5;
inline bool CollectionDef::has_any_list() const {
  return kind_case() == kAnyList;
}
inline void CollectionDef::set_has_any_list() {
  _oneof_case_[0] = kAnyList;
}
inline void CollectionDef::clear_any_list() {
  if (has_any_list()) {
    delete kind_.any_list_;
    clear_has_kind();
  }
}
inline  const ::tensorflow::CollectionDef_AnyList& CollectionDef::any_list() const {
  // @@protoc_insertion_point(field_get:tensorflow.CollectionDef.any_list)
  return has_any_list()
      ? *kind_.any_list_
      : ::tensorflow::CollectionDef_AnyList::default_instance();
}
inline ::tensorflow::CollectionDef_AnyList* CollectionDef::mutable_any_list() {
  if (!has_any_list()) {
    clear_kind();
    set_has_any_list();
    kind_.any_list_ = new ::tensorflow::CollectionDef_AnyList;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.CollectionDef.any_list)
  return kind_.any_list_;
}
inline ::tensorflow::CollectionDef_AnyList* CollectionDef::release_any_list() {
  // @@protoc_insertion_point(field_release:tensorflow.CollectionDef.any_list)
  if (has_any_list()) {
    clear_has_kind();
    ::tensorflow::CollectionDef_AnyList* temp = kind_.any_list_;
    kind_.any_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CollectionDef::set_allocated_any_list(::tensorflow::CollectionDef_AnyList* any_list) {
  clear_kind();
  if (any_list) {
    set_has_any_list();
    kind_.any_list_ = any_list;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CollectionDef.any_list)
}

inline bool CollectionDef::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void CollectionDef::clear_has_kind() {
  _oneof_case_[0] = KIND_NOT_SET;
}
inline CollectionDef::KindCase CollectionDef::kind_case() const {
  return CollectionDef::KindCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tensorflow

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto__INCLUDED
