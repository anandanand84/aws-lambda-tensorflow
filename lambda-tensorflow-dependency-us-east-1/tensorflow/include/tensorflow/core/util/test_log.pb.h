// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/util/test_log.proto

#ifndef PROTOBUF_tensorflow_2fcore_2futil_2ftest_5flog_2eproto__INCLUDED
#define PROTOBUF_tensorflow_2fcore_2futil_2ftest_5flog_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/map.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
// @@protoc_insertion_point(includes)

namespace tensorflow {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();
void protobuf_AssignDesc_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();
void protobuf_ShutdownFile_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();

class AvailableDeviceInfo;
class BenchmarkEntries;
class BenchmarkEntry;
class BuildConfiguration;
class CPUInfo;
class CommitId;
class EntryValue;
class GPUInfo;
class MachineConfiguration;
class MemoryInfo;
class PlatformInfo;
class RunConfiguration;
class TestResults;

// ===================================================================

class EntryValue : public ::google::protobuf::Message {
 public:
  EntryValue();
  virtual ~EntryValue();

  EntryValue(const EntryValue& from);

  inline EntryValue& operator=(const EntryValue& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EntryValue& default_instance();

  enum KindCase {
    kDoubleValue = 1,
    kStringValue = 2,
    KIND_NOT_SET = 0,
  };

  void Swap(EntryValue* other);

  // implements Message ----------------------------------------------

  inline EntryValue* New() const { return New(NULL); }

  EntryValue* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EntryValue& from);
  void MergeFrom(const EntryValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EntryValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double double_value = 1;
  private:
  bool has_double_value() const;
  public:
  void clear_double_value();
  static const int kDoubleValueFieldNumber = 1;
  double double_value() const;
  void set_double_value(double value);

  // optional string string_value = 2;
  private:
  bool has_string_value() const;
  public:
  void clear_string_value();
  static const int kStringValueFieldNumber = 2;
  const ::std::string& string_value() const;
  void set_string_value(const ::std::string& value);
  void set_string_value(const char* value);
  void set_string_value(const char* value, size_t size);
  ::std::string* mutable_string_value();
  ::std::string* release_string_value();
  void set_allocated_string_value(::std::string* string_value);

  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.EntryValue)
 private:
  inline void set_has_double_value();
  inline void set_has_string_value();

  inline bool has_kind() const;
  void clear_kind();
  inline void clear_has_kind();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union KindUnion {
    KindUnion() {}
    double double_value_;
    ::google::protobuf::internal::ArenaStringPtr string_value_;
  } kind_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();

  void InitAsDefaultInstance();
  static EntryValue* default_instance_;
};
// -------------------------------------------------------------------

class BenchmarkEntry : public ::google::protobuf::Message {
 public:
  BenchmarkEntry();
  virtual ~BenchmarkEntry();

  BenchmarkEntry(const BenchmarkEntry& from);

  inline BenchmarkEntry& operator=(const BenchmarkEntry& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BenchmarkEntry& default_instance();

  void Swap(BenchmarkEntry* other);

  // implements Message ----------------------------------------------

  inline BenchmarkEntry* New() const { return New(NULL); }

  BenchmarkEntry* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BenchmarkEntry& from);
  void MergeFrom(const BenchmarkEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BenchmarkEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional int64 iters = 2;
  void clear_iters();
  static const int kItersFieldNumber = 2;
  ::google::protobuf::int64 iters() const;
  void set_iters(::google::protobuf::int64 value);

  // optional double cpu_time = 3;
  void clear_cpu_time();
  static const int kCpuTimeFieldNumber = 3;
  double cpu_time() const;
  void set_cpu_time(double value);

  // optional double wall_time = 4;
  void clear_wall_time();
  static const int kWallTimeFieldNumber = 4;
  double wall_time() const;
  void set_wall_time(double value);

  // optional double throughput = 5;
  void clear_throughput();
  static const int kThroughputFieldNumber = 5;
  double throughput() const;
  void set_throughput(double value);

  // map<string, .tensorflow.EntryValue> extras = 6;
  int extras_size() const;
  void clear_extras();
  static const int kExtrasFieldNumber = 6;
  const ::google::protobuf::Map< ::std::string, ::tensorflow::EntryValue >&
      extras() const;
  ::google::protobuf::Map< ::std::string, ::tensorflow::EntryValue >*
      mutable_extras();

  // @@protoc_insertion_point(class_scope:tensorflow.BenchmarkEntry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int64 iters_;
  double cpu_time_;
  double wall_time_;
  double throughput_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::tensorflow::EntryValue,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      BenchmarkEntry_ExtrasEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, ::tensorflow::EntryValue,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > extras_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();

  void InitAsDefaultInstance();
  static BenchmarkEntry* default_instance_;
};
// -------------------------------------------------------------------

class BenchmarkEntries : public ::google::protobuf::Message {
 public:
  BenchmarkEntries();
  virtual ~BenchmarkEntries();

  BenchmarkEntries(const BenchmarkEntries& from);

  inline BenchmarkEntries& operator=(const BenchmarkEntries& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BenchmarkEntries& default_instance();

  void Swap(BenchmarkEntries* other);

  // implements Message ----------------------------------------------

  inline BenchmarkEntries* New() const { return New(NULL); }

  BenchmarkEntries* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BenchmarkEntries& from);
  void MergeFrom(const BenchmarkEntries& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BenchmarkEntries* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorflow.BenchmarkEntry entry = 1;
  int entry_size() const;
  void clear_entry();
  static const int kEntryFieldNumber = 1;
  const ::tensorflow::BenchmarkEntry& entry(int index) const;
  ::tensorflow::BenchmarkEntry* mutable_entry(int index);
  ::tensorflow::BenchmarkEntry* add_entry();
  ::google::protobuf::RepeatedPtrField< ::tensorflow::BenchmarkEntry >*
      mutable_entry();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::BenchmarkEntry >&
      entry() const;

  // @@protoc_insertion_point(class_scope:tensorflow.BenchmarkEntries)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::BenchmarkEntry > entry_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();

  void InitAsDefaultInstance();
  static BenchmarkEntries* default_instance_;
};
// -------------------------------------------------------------------

class BuildConfiguration : public ::google::protobuf::Message {
 public:
  BuildConfiguration();
  virtual ~BuildConfiguration();

  BuildConfiguration(const BuildConfiguration& from);

  inline BuildConfiguration& operator=(const BuildConfiguration& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuildConfiguration& default_instance();

  void Swap(BuildConfiguration* other);

  // implements Message ----------------------------------------------

  inline BuildConfiguration* New() const { return New(NULL); }

  BuildConfiguration* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuildConfiguration& from);
  void MergeFrom(const BuildConfiguration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BuildConfiguration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string mode = 1;
  void clear_mode();
  static const int kModeFieldNumber = 1;
  const ::std::string& mode() const;
  void set_mode(const ::std::string& value);
  void set_mode(const char* value);
  void set_mode(const char* value, size_t size);
  ::std::string* mutable_mode();
  ::std::string* release_mode();
  void set_allocated_mode(::std::string* mode);

  // repeated string cc_flags = 2;
  int cc_flags_size() const;
  void clear_cc_flags();
  static const int kCcFlagsFieldNumber = 2;
  const ::std::string& cc_flags(int index) const;
  ::std::string* mutable_cc_flags(int index);
  void set_cc_flags(int index, const ::std::string& value);
  void set_cc_flags(int index, const char* value);
  void set_cc_flags(int index, const char* value, size_t size);
  ::std::string* add_cc_flags();
  void add_cc_flags(const ::std::string& value);
  void add_cc_flags(const char* value);
  void add_cc_flags(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& cc_flags() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_cc_flags();

  // repeated string opts = 3;
  int opts_size() const;
  void clear_opts();
  static const int kOptsFieldNumber = 3;
  const ::std::string& opts(int index) const;
  ::std::string* mutable_opts(int index);
  void set_opts(int index, const ::std::string& value);
  void set_opts(int index, const char* value);
  void set_opts(int index, const char* value, size_t size);
  ::std::string* add_opts();
  void add_opts(const ::std::string& value);
  void add_opts(const char* value);
  void add_opts(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& opts() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_opts();

  // @@protoc_insertion_point(class_scope:tensorflow.BuildConfiguration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr mode_;
  ::google::protobuf::RepeatedPtrField< ::std::string> cc_flags_;
  ::google::protobuf::RepeatedPtrField< ::std::string> opts_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();

  void InitAsDefaultInstance();
  static BuildConfiguration* default_instance_;
};
// -------------------------------------------------------------------

class CommitId : public ::google::protobuf::Message {
 public:
  CommitId();
  virtual ~CommitId();

  CommitId(const CommitId& from);

  inline CommitId& operator=(const CommitId& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommitId& default_instance();

  enum KindCase {
    kChangelist = 1,
    kHash = 2,
    KIND_NOT_SET = 0,
  };

  void Swap(CommitId* other);

  // implements Message ----------------------------------------------

  inline CommitId* New() const { return New(NULL); }

  CommitId* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommitId& from);
  void MergeFrom(const CommitId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommitId* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 changelist = 1;
  private:
  bool has_changelist() const;
  public:
  void clear_changelist();
  static const int kChangelistFieldNumber = 1;
  ::google::protobuf::int64 changelist() const;
  void set_changelist(::google::protobuf::int64 value);

  // optional string hash = 2;
  private:
  bool has_hash() const;
  public:
  void clear_hash();
  static const int kHashFieldNumber = 2;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // optional string snapshot = 3;
  void clear_snapshot();
  static const int kSnapshotFieldNumber = 3;
  const ::std::string& snapshot() const;
  void set_snapshot(const ::std::string& value);
  void set_snapshot(const char* value);
  void set_snapshot(const char* value, size_t size);
  ::std::string* mutable_snapshot();
  ::std::string* release_snapshot();
  void set_allocated_snapshot(::std::string* snapshot);

  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.CommitId)
 private:
  inline void set_has_changelist();
  inline void set_has_hash();

  inline bool has_kind() const;
  void clear_kind();
  inline void clear_has_kind();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr snapshot_;
  union KindUnion {
    KindUnion() {}
    ::google::protobuf::int64 changelist_;
    ::google::protobuf::internal::ArenaStringPtr hash_;
  } kind_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();

  void InitAsDefaultInstance();
  static CommitId* default_instance_;
};
// -------------------------------------------------------------------

class CPUInfo : public ::google::protobuf::Message {
 public:
  CPUInfo();
  virtual ~CPUInfo();

  CPUInfo(const CPUInfo& from);

  inline CPUInfo& operator=(const CPUInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CPUInfo& default_instance();

  void Swap(CPUInfo* other);

  // implements Message ----------------------------------------------

  inline CPUInfo* New() const { return New(NULL); }

  CPUInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CPUInfo& from);
  void MergeFrom(const CPUInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CPUInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // optional int64 num_cores = 1;
  void clear_num_cores();
  static const int kNumCoresFieldNumber = 1;
  ::google::protobuf::int64 num_cores() const;
  void set_num_cores(::google::protobuf::int64 value);

  // optional int64 num_cores_allowed = 2;
  void clear_num_cores_allowed();
  static const int kNumCoresAllowedFieldNumber = 2;
  ::google::protobuf::int64 num_cores_allowed() const;
  void set_num_cores_allowed(::google::protobuf::int64 value);

  // optional double mhz_per_cpu = 3;
  void clear_mhz_per_cpu();
  static const int kMhzPerCpuFieldNumber = 3;
  double mhz_per_cpu() const;
  void set_mhz_per_cpu(double value);

  // optional string cpu_info = 4;
  void clear_cpu_info();
  static const int kCpuInfoFieldNumber = 4;
  const ::std::string& cpu_info() const;
  void set_cpu_info(const ::std::string& value);
  void set_cpu_info(const char* value);
  void set_cpu_info(const char* value, size_t size);
  ::std::string* mutable_cpu_info();
  ::std::string* release_cpu_info();
  void set_allocated_cpu_info(::std::string* cpu_info);

  // optional string cpu_governor = 5;
  void clear_cpu_governor();
  static const int kCpuGovernorFieldNumber = 5;
  const ::std::string& cpu_governor() const;
  void set_cpu_governor(const ::std::string& value);
  void set_cpu_governor(const char* value);
  void set_cpu_governor(const char* value, size_t size);
  ::std::string* mutable_cpu_governor();
  ::std::string* release_cpu_governor();
  void set_allocated_cpu_governor(::std::string* cpu_governor);

  // map<string, int64> cache_size = 6;
  int cache_size_size() const;
  void clear_cache_size();
  static const int kCacheSizeFieldNumber = 6;
  const ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >&
      cache_size() const;
  ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >*
      mutable_cache_size();

  // @@protoc_insertion_point(class_scope:tensorflow.CPUInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 num_cores_;
  ::google::protobuf::int64 num_cores_allowed_;
  double mhz_per_cpu_;
  ::google::protobuf::internal::ArenaStringPtr cpu_info_;
  ::google::protobuf::internal::ArenaStringPtr cpu_governor_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::google::protobuf::int64,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
      0 >
      CPUInfo_CacheSizeEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, ::google::protobuf::int64,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
      0 > cache_size_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();

  void InitAsDefaultInstance();
  static CPUInfo* default_instance_;
};
// -------------------------------------------------------------------

class MemoryInfo : public ::google::protobuf::Message {
 public:
  MemoryInfo();
  virtual ~MemoryInfo();

  MemoryInfo(const MemoryInfo& from);

  inline MemoryInfo& operator=(const MemoryInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemoryInfo& default_instance();

  void Swap(MemoryInfo* other);

  // implements Message ----------------------------------------------

  inline MemoryInfo* New() const { return New(NULL); }

  MemoryInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MemoryInfo& from);
  void MergeFrom(const MemoryInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MemoryInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 total = 1;
  void clear_total();
  static const int kTotalFieldNumber = 1;
  ::google::protobuf::int64 total() const;
  void set_total(::google::protobuf::int64 value);

  // optional int64 available = 2;
  void clear_available();
  static const int kAvailableFieldNumber = 2;
  ::google::protobuf::int64 available() const;
  void set_available(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.MemoryInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 total_;
  ::google::protobuf::int64 available_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();

  void InitAsDefaultInstance();
  static MemoryInfo* default_instance_;
};
// -------------------------------------------------------------------

class GPUInfo : public ::google::protobuf::Message {
 public:
  GPUInfo();
  virtual ~GPUInfo();

  GPUInfo(const GPUInfo& from);

  inline GPUInfo& operator=(const GPUInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GPUInfo& default_instance();

  void Swap(GPUInfo* other);

  // implements Message ----------------------------------------------

  inline GPUInfo* New() const { return New(NULL); }

  GPUInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPUInfo& from);
  void MergeFrom(const GPUInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GPUInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string model = 1;
  void clear_model();
  static const int kModelFieldNumber = 1;
  const ::std::string& model() const;
  void set_model(const ::std::string& value);
  void set_model(const char* value);
  void set_model(const char* value, size_t size);
  ::std::string* mutable_model();
  ::std::string* release_model();
  void set_allocated_model(::std::string* model);

  // optional string uuid = 2;
  void clear_uuid();
  static const int kUuidFieldNumber = 2;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // optional string bus_id = 3;
  void clear_bus_id();
  static const int kBusIdFieldNumber = 3;
  const ::std::string& bus_id() const;
  void set_bus_id(const ::std::string& value);
  void set_bus_id(const char* value);
  void set_bus_id(const char* value, size_t size);
  ::std::string* mutable_bus_id();
  ::std::string* release_bus_id();
  void set_allocated_bus_id(::std::string* bus_id);

  // @@protoc_insertion_point(class_scope:tensorflow.GPUInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr model_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  ::google::protobuf::internal::ArenaStringPtr bus_id_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();

  void InitAsDefaultInstance();
  static GPUInfo* default_instance_;
};
// -------------------------------------------------------------------

class PlatformInfo : public ::google::protobuf::Message {
 public:
  PlatformInfo();
  virtual ~PlatformInfo();

  PlatformInfo(const PlatformInfo& from);

  inline PlatformInfo& operator=(const PlatformInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlatformInfo& default_instance();

  void Swap(PlatformInfo* other);

  // implements Message ----------------------------------------------

  inline PlatformInfo* New() const { return New(NULL); }

  PlatformInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlatformInfo& from);
  void MergeFrom(const PlatformInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlatformInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string bits = 1;
  void clear_bits();
  static const int kBitsFieldNumber = 1;
  const ::std::string& bits() const;
  void set_bits(const ::std::string& value);
  void set_bits(const char* value);
  void set_bits(const char* value, size_t size);
  ::std::string* mutable_bits();
  ::std::string* release_bits();
  void set_allocated_bits(::std::string* bits);

  // optional string linkage = 2;
  void clear_linkage();
  static const int kLinkageFieldNumber = 2;
  const ::std::string& linkage() const;
  void set_linkage(const ::std::string& value);
  void set_linkage(const char* value);
  void set_linkage(const char* value, size_t size);
  ::std::string* mutable_linkage();
  ::std::string* release_linkage();
  void set_allocated_linkage(::std::string* linkage);

  // optional string machine = 3;
  void clear_machine();
  static const int kMachineFieldNumber = 3;
  const ::std::string& machine() const;
  void set_machine(const ::std::string& value);
  void set_machine(const char* value);
  void set_machine(const char* value, size_t size);
  ::std::string* mutable_machine();
  ::std::string* release_machine();
  void set_allocated_machine(::std::string* machine);

  // optional string release = 4;
  void clear_release();
  static const int kReleaseFieldNumber = 4;
  const ::std::string& release() const;
  void set_release(const ::std::string& value);
  void set_release(const char* value);
  void set_release(const char* value, size_t size);
  ::std::string* mutable_release();
  ::std::string* release_release();
  void set_allocated_release(::std::string* release);

  // optional string system = 5;
  void clear_system();
  static const int kSystemFieldNumber = 5;
  const ::std::string& system() const;
  void set_system(const ::std::string& value);
  void set_system(const char* value);
  void set_system(const char* value, size_t size);
  ::std::string* mutable_system();
  ::std::string* release_system();
  void set_allocated_system(::std::string* system);

  // optional string version = 6;
  void clear_version();
  static const int kVersionFieldNumber = 6;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:tensorflow.PlatformInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr bits_;
  ::google::protobuf::internal::ArenaStringPtr linkage_;
  ::google::protobuf::internal::ArenaStringPtr machine_;
  ::google::protobuf::internal::ArenaStringPtr release_;
  ::google::protobuf::internal::ArenaStringPtr system_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();

  void InitAsDefaultInstance();
  static PlatformInfo* default_instance_;
};
// -------------------------------------------------------------------

class AvailableDeviceInfo : public ::google::protobuf::Message {
 public:
  AvailableDeviceInfo();
  virtual ~AvailableDeviceInfo();

  AvailableDeviceInfo(const AvailableDeviceInfo& from);

  inline AvailableDeviceInfo& operator=(const AvailableDeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AvailableDeviceInfo& default_instance();

  void Swap(AvailableDeviceInfo* other);

  // implements Message ----------------------------------------------

  inline AvailableDeviceInfo* New() const { return New(NULL); }

  AvailableDeviceInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AvailableDeviceInfo& from);
  void MergeFrom(const AvailableDeviceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AvailableDeviceInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional int64 memory_limit = 3;
  void clear_memory_limit();
  static const int kMemoryLimitFieldNumber = 3;
  ::google::protobuf::int64 memory_limit() const;
  void set_memory_limit(::google::protobuf::int64 value);

  // optional string physical_description = 4;
  void clear_physical_description();
  static const int kPhysicalDescriptionFieldNumber = 4;
  const ::std::string& physical_description() const;
  void set_physical_description(const ::std::string& value);
  void set_physical_description(const char* value);
  void set_physical_description(const char* value, size_t size);
  ::std::string* mutable_physical_description();
  ::std::string* release_physical_description();
  void set_allocated_physical_description(::std::string* physical_description);

  // @@protoc_insertion_point(class_scope:tensorflow.AvailableDeviceInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::int64 memory_limit_;
  ::google::protobuf::internal::ArenaStringPtr physical_description_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();

  void InitAsDefaultInstance();
  static AvailableDeviceInfo* default_instance_;
};
// -------------------------------------------------------------------

class MachineConfiguration : public ::google::protobuf::Message {
 public:
  MachineConfiguration();
  virtual ~MachineConfiguration();

  MachineConfiguration(const MachineConfiguration& from);

  inline MachineConfiguration& operator=(const MachineConfiguration& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MachineConfiguration& default_instance();

  void Swap(MachineConfiguration* other);

  // implements Message ----------------------------------------------

  inline MachineConfiguration* New() const { return New(NULL); }

  MachineConfiguration* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MachineConfiguration& from);
  void MergeFrom(const MachineConfiguration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MachineConfiguration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string hostname = 1;
  void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  const ::std::string& hostname() const;
  void set_hostname(const ::std::string& value);
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  ::std::string* mutable_hostname();
  ::std::string* release_hostname();
  void set_allocated_hostname(::std::string* hostname);

  // optional string serial_identifier = 7;
  void clear_serial_identifier();
  static const int kSerialIdentifierFieldNumber = 7;
  const ::std::string& serial_identifier() const;
  void set_serial_identifier(const ::std::string& value);
  void set_serial_identifier(const char* value);
  void set_serial_identifier(const char* value, size_t size);
  ::std::string* mutable_serial_identifier();
  ::std::string* release_serial_identifier();
  void set_allocated_serial_identifier(::std::string* serial_identifier);

  // optional .tensorflow.PlatformInfo platform_info = 2;
  bool has_platform_info() const;
  void clear_platform_info();
  static const int kPlatformInfoFieldNumber = 2;
  const ::tensorflow::PlatformInfo& platform_info() const;
  ::tensorflow::PlatformInfo* mutable_platform_info();
  ::tensorflow::PlatformInfo* release_platform_info();
  void set_allocated_platform_info(::tensorflow::PlatformInfo* platform_info);

  // optional .tensorflow.CPUInfo cpu_info = 3;
  bool has_cpu_info() const;
  void clear_cpu_info();
  static const int kCpuInfoFieldNumber = 3;
  const ::tensorflow::CPUInfo& cpu_info() const;
  ::tensorflow::CPUInfo* mutable_cpu_info();
  ::tensorflow::CPUInfo* release_cpu_info();
  void set_allocated_cpu_info(::tensorflow::CPUInfo* cpu_info);

  // repeated .google.protobuf.Any device_info = 4;
  int device_info_size() const;
  void clear_device_info();
  static const int kDeviceInfoFieldNumber = 4;
  const ::google::protobuf::Any& device_info(int index) const;
  ::google::protobuf::Any* mutable_device_info(int index);
  ::google::protobuf::Any* add_device_info();
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_device_info();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
      device_info() const;

  // repeated .tensorflow.AvailableDeviceInfo available_device_info = 5;
  int available_device_info_size() const;
  void clear_available_device_info();
  static const int kAvailableDeviceInfoFieldNumber = 5;
  const ::tensorflow::AvailableDeviceInfo& available_device_info(int index) const;
  ::tensorflow::AvailableDeviceInfo* mutable_available_device_info(int index);
  ::tensorflow::AvailableDeviceInfo* add_available_device_info();
  ::google::protobuf::RepeatedPtrField< ::tensorflow::AvailableDeviceInfo >*
      mutable_available_device_info();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::AvailableDeviceInfo >&
      available_device_info() const;

  // optional .tensorflow.MemoryInfo memory_info = 6;
  bool has_memory_info() const;
  void clear_memory_info();
  static const int kMemoryInfoFieldNumber = 6;
  const ::tensorflow::MemoryInfo& memory_info() const;
  ::tensorflow::MemoryInfo* mutable_memory_info();
  ::tensorflow::MemoryInfo* release_memory_info();
  void set_allocated_memory_info(::tensorflow::MemoryInfo* memory_info);

  // @@protoc_insertion_point(class_scope:tensorflow.MachineConfiguration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr hostname_;
  ::google::protobuf::internal::ArenaStringPtr serial_identifier_;
  ::tensorflow::PlatformInfo* platform_info_;
  ::tensorflow::CPUInfo* cpu_info_;
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > device_info_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::AvailableDeviceInfo > available_device_info_;
  ::tensorflow::MemoryInfo* memory_info_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();

  void InitAsDefaultInstance();
  static MachineConfiguration* default_instance_;
};
// -------------------------------------------------------------------

class RunConfiguration : public ::google::protobuf::Message {
 public:
  RunConfiguration();
  virtual ~RunConfiguration();

  RunConfiguration(const RunConfiguration& from);

  inline RunConfiguration& operator=(const RunConfiguration& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RunConfiguration& default_instance();

  void Swap(RunConfiguration* other);

  // implements Message ----------------------------------------------

  inline RunConfiguration* New() const { return New(NULL); }

  RunConfiguration* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RunConfiguration& from);
  void MergeFrom(const RunConfiguration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RunConfiguration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string argument = 1;
  int argument_size() const;
  void clear_argument();
  static const int kArgumentFieldNumber = 1;
  const ::std::string& argument(int index) const;
  ::std::string* mutable_argument(int index);
  void set_argument(int index, const ::std::string& value);
  void set_argument(int index, const char* value);
  void set_argument(int index, const char* value, size_t size);
  ::std::string* add_argument();
  void add_argument(const ::std::string& value);
  void add_argument(const char* value);
  void add_argument(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& argument() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_argument();

  // @@protoc_insertion_point(class_scope:tensorflow.RunConfiguration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::std::string> argument_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();

  void InitAsDefaultInstance();
  static RunConfiguration* default_instance_;
};
// -------------------------------------------------------------------

class TestResults : public ::google::protobuf::Message {
 public:
  TestResults();
  virtual ~TestResults();

  TestResults(const TestResults& from);

  inline TestResults& operator=(const TestResults& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestResults& default_instance();

  void Swap(TestResults* other);

  // implements Message ----------------------------------------------

  inline TestResults* New() const { return New(NULL); }

  TestResults* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TestResults& from);
  void MergeFrom(const TestResults& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TestResults* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string target = 1;
  void clear_target();
  static const int kTargetFieldNumber = 1;
  const ::std::string& target() const;
  void set_target(const ::std::string& value);
  void set_target(const char* value);
  void set_target(const char* value, size_t size);
  ::std::string* mutable_target();
  ::std::string* release_target();
  void set_allocated_target(::std::string* target);

  // optional .tensorflow.BenchmarkEntries entries = 2;
  bool has_entries() const;
  void clear_entries();
  static const int kEntriesFieldNumber = 2;
  const ::tensorflow::BenchmarkEntries& entries() const;
  ::tensorflow::BenchmarkEntries* mutable_entries();
  ::tensorflow::BenchmarkEntries* release_entries();
  void set_allocated_entries(::tensorflow::BenchmarkEntries* entries);

  // optional .tensorflow.BuildConfiguration build_configuration = 3;
  bool has_build_configuration() const;
  void clear_build_configuration();
  static const int kBuildConfigurationFieldNumber = 3;
  const ::tensorflow::BuildConfiguration& build_configuration() const;
  ::tensorflow::BuildConfiguration* mutable_build_configuration();
  ::tensorflow::BuildConfiguration* release_build_configuration();
  void set_allocated_build_configuration(::tensorflow::BuildConfiguration* build_configuration);

  // optional .tensorflow.CommitId commit_id = 4;
  bool has_commit_id() const;
  void clear_commit_id();
  static const int kCommitIdFieldNumber = 4;
  const ::tensorflow::CommitId& commit_id() const;
  ::tensorflow::CommitId* mutable_commit_id();
  ::tensorflow::CommitId* release_commit_id();
  void set_allocated_commit_id(::tensorflow::CommitId* commit_id);

  // optional int64 start_time = 5;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 5;
  ::google::protobuf::int64 start_time() const;
  void set_start_time(::google::protobuf::int64 value);

  // optional double run_time = 6;
  void clear_run_time();
  static const int kRunTimeFieldNumber = 6;
  double run_time() const;
  void set_run_time(double value);

  // optional .tensorflow.MachineConfiguration machine_configuration = 7;
  bool has_machine_configuration() const;
  void clear_machine_configuration();
  static const int kMachineConfigurationFieldNumber = 7;
  const ::tensorflow::MachineConfiguration& machine_configuration() const;
  ::tensorflow::MachineConfiguration* mutable_machine_configuration();
  ::tensorflow::MachineConfiguration* release_machine_configuration();
  void set_allocated_machine_configuration(::tensorflow::MachineConfiguration* machine_configuration);

  // optional .tensorflow.RunConfiguration run_configuration = 8;
  bool has_run_configuration() const;
  void clear_run_configuration();
  static const int kRunConfigurationFieldNumber = 8;
  const ::tensorflow::RunConfiguration& run_configuration() const;
  ::tensorflow::RunConfiguration* mutable_run_configuration();
  ::tensorflow::RunConfiguration* release_run_configuration();
  void set_allocated_run_configuration(::tensorflow::RunConfiguration* run_configuration);

  // @@protoc_insertion_point(class_scope:tensorflow.TestResults)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr target_;
  ::tensorflow::BenchmarkEntries* entries_;
  ::tensorflow::BuildConfiguration* build_configuration_;
  ::tensorflow::CommitId* commit_id_;
  ::google::protobuf::int64 start_time_;
  double run_time_;
  ::tensorflow::MachineConfiguration* machine_configuration_;
  ::tensorflow::RunConfiguration* run_configuration_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();
  friend void protobuf_AssignDesc_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();
  friend void protobuf_ShutdownFile_tensorflow_2fcore_2futil_2ftest_5flog_2eproto();

  void InitAsDefaultInstance();
  static TestResults* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// EntryValue

// optional double double_value = 1;
inline bool EntryValue::has_double_value() const {
  return kind_case() == kDoubleValue;
}
inline void EntryValue::set_has_double_value() {
  _oneof_case_[0] = kDoubleValue;
}
inline void EntryValue::clear_double_value() {
  if (has_double_value()) {
    kind_.double_value_ = 0;
    clear_has_kind();
  }
}
inline double EntryValue::double_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.EntryValue.double_value)
  if (has_double_value()) {
    return kind_.double_value_;
  }
  return 0;
}
inline void EntryValue::set_double_value(double value) {
  if (!has_double_value()) {
    clear_kind();
    set_has_double_value();
  }
  kind_.double_value_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.EntryValue.double_value)
}

// optional string string_value = 2;
inline bool EntryValue::has_string_value() const {
  return kind_case() == kStringValue;
}
inline void EntryValue::set_has_string_value() {
  _oneof_case_[0] = kStringValue;
}
inline void EntryValue::clear_string_value() {
  if (has_string_value()) {
    kind_.string_value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_kind();
  }
}
inline const ::std::string& EntryValue::string_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.EntryValue.string_value)
  if (has_string_value()) {
    return kind_.string_value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void EntryValue::set_string_value(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.EntryValue.string_value)
  if (!has_string_value()) {
    clear_kind();
    set_has_string_value();
    kind_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  kind_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.EntryValue.string_value)
}
inline void EntryValue::set_string_value(const char* value) {
  if (!has_string_value()) {
    clear_kind();
    set_has_string_value();
    kind_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  kind_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.EntryValue.string_value)
}
inline void EntryValue::set_string_value(const char* value, size_t size) {
  if (!has_string_value()) {
    clear_kind();
    set_has_string_value();
    kind_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  kind_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.EntryValue.string_value)
}
inline ::std::string* EntryValue::mutable_string_value() {
  if (!has_string_value()) {
    clear_kind();
    set_has_string_value();
    kind_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.EntryValue.string_value)
  return kind_.string_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EntryValue::release_string_value() {
  // @@protoc_insertion_point(field_release:tensorflow.EntryValue.string_value)
  if (has_string_value()) {
    clear_has_kind();
    return kind_.string_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void EntryValue::set_allocated_string_value(::std::string* string_value) {
  if (!has_string_value()) {
    kind_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_kind();
  if (string_value != NULL) {
    set_has_string_value();
    kind_.string_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        string_value);
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.EntryValue.string_value)
}

inline bool EntryValue::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void EntryValue::clear_has_kind() {
  _oneof_case_[0] = KIND_NOT_SET;
}
inline EntryValue::KindCase EntryValue::kind_case() const {
  return EntryValue::KindCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BenchmarkEntry

// optional string name = 1;
inline void BenchmarkEntry::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BenchmarkEntry::name() const {
  // @@protoc_insertion_point(field_get:tensorflow.BenchmarkEntry.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BenchmarkEntry::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.BenchmarkEntry.name)
}
inline void BenchmarkEntry::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.BenchmarkEntry.name)
}
inline void BenchmarkEntry::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.BenchmarkEntry.name)
}
inline ::std::string* BenchmarkEntry::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.BenchmarkEntry.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BenchmarkEntry::release_name() {
  // @@protoc_insertion_point(field_release:tensorflow.BenchmarkEntry.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BenchmarkEntry::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.BenchmarkEntry.name)
}

// optional int64 iters = 2;
inline void BenchmarkEntry::clear_iters() {
  iters_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BenchmarkEntry::iters() const {
  // @@protoc_insertion_point(field_get:tensorflow.BenchmarkEntry.iters)
  return iters_;
}
inline void BenchmarkEntry::set_iters(::google::protobuf::int64 value) {
  
  iters_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.BenchmarkEntry.iters)
}

// optional double cpu_time = 3;
inline void BenchmarkEntry::clear_cpu_time() {
  cpu_time_ = 0;
}
inline double BenchmarkEntry::cpu_time() const {
  // @@protoc_insertion_point(field_get:tensorflow.BenchmarkEntry.cpu_time)
  return cpu_time_;
}
inline void BenchmarkEntry::set_cpu_time(double value) {
  
  cpu_time_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.BenchmarkEntry.cpu_time)
}

// optional double wall_time = 4;
inline void BenchmarkEntry::clear_wall_time() {
  wall_time_ = 0;
}
inline double BenchmarkEntry::wall_time() const {
  // @@protoc_insertion_point(field_get:tensorflow.BenchmarkEntry.wall_time)
  return wall_time_;
}
inline void BenchmarkEntry::set_wall_time(double value) {
  
  wall_time_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.BenchmarkEntry.wall_time)
}

// optional double throughput = 5;
inline void BenchmarkEntry::clear_throughput() {
  throughput_ = 0;
}
inline double BenchmarkEntry::throughput() const {
  // @@protoc_insertion_point(field_get:tensorflow.BenchmarkEntry.throughput)
  return throughput_;
}
inline void BenchmarkEntry::set_throughput(double value) {
  
  throughput_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.BenchmarkEntry.throughput)
}

// map<string, .tensorflow.EntryValue> extras = 6;
inline int BenchmarkEntry::extras_size() const {
  return extras_.size();
}
inline void BenchmarkEntry::clear_extras() {
  extras_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::tensorflow::EntryValue >&
BenchmarkEntry::extras() const {
  // @@protoc_insertion_point(field_map:tensorflow.BenchmarkEntry.extras)
  return extras_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::tensorflow::EntryValue >*
BenchmarkEntry::mutable_extras() {
  // @@protoc_insertion_point(field_mutable_map:tensorflow.BenchmarkEntry.extras)
  return extras_.MutableMap();
}

// -------------------------------------------------------------------

// BenchmarkEntries

// repeated .tensorflow.BenchmarkEntry entry = 1;
inline int BenchmarkEntries::entry_size() const {
  return entry_.size();
}
inline void BenchmarkEntries::clear_entry() {
  entry_.Clear();
}
inline const ::tensorflow::BenchmarkEntry& BenchmarkEntries::entry(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.BenchmarkEntries.entry)
  return entry_.Get(index);
}
inline ::tensorflow::BenchmarkEntry* BenchmarkEntries::mutable_entry(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.BenchmarkEntries.entry)
  return entry_.Mutable(index);
}
inline ::tensorflow::BenchmarkEntry* BenchmarkEntries::add_entry() {
  // @@protoc_insertion_point(field_add:tensorflow.BenchmarkEntries.entry)
  return entry_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::BenchmarkEntry >*
BenchmarkEntries::mutable_entry() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.BenchmarkEntries.entry)
  return &entry_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::BenchmarkEntry >&
BenchmarkEntries::entry() const {
  // @@protoc_insertion_point(field_list:tensorflow.BenchmarkEntries.entry)
  return entry_;
}

// -------------------------------------------------------------------

// BuildConfiguration

// optional string mode = 1;
inline void BuildConfiguration::clear_mode() {
  mode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BuildConfiguration::mode() const {
  // @@protoc_insertion_point(field_get:tensorflow.BuildConfiguration.mode)
  return mode_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BuildConfiguration::set_mode(const ::std::string& value) {
  
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.BuildConfiguration.mode)
}
inline void BuildConfiguration::set_mode(const char* value) {
  
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.BuildConfiguration.mode)
}
inline void BuildConfiguration::set_mode(const char* value, size_t size) {
  
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.BuildConfiguration.mode)
}
inline ::std::string* BuildConfiguration::mutable_mode() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.BuildConfiguration.mode)
  return mode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BuildConfiguration::release_mode() {
  // @@protoc_insertion_point(field_release:tensorflow.BuildConfiguration.mode)
  
  return mode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BuildConfiguration::set_allocated_mode(::std::string* mode) {
  if (mode != NULL) {
    
  } else {
    
  }
  mode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mode);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.BuildConfiguration.mode)
}

// repeated string cc_flags = 2;
inline int BuildConfiguration::cc_flags_size() const {
  return cc_flags_.size();
}
inline void BuildConfiguration::clear_cc_flags() {
  cc_flags_.Clear();
}
inline const ::std::string& BuildConfiguration::cc_flags(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.BuildConfiguration.cc_flags)
  return cc_flags_.Get(index);
}
inline ::std::string* BuildConfiguration::mutable_cc_flags(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.BuildConfiguration.cc_flags)
  return cc_flags_.Mutable(index);
}
inline void BuildConfiguration::set_cc_flags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.BuildConfiguration.cc_flags)
  cc_flags_.Mutable(index)->assign(value);
}
inline void BuildConfiguration::set_cc_flags(int index, const char* value) {
  cc_flags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.BuildConfiguration.cc_flags)
}
inline void BuildConfiguration::set_cc_flags(int index, const char* value, size_t size) {
  cc_flags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.BuildConfiguration.cc_flags)
}
inline ::std::string* BuildConfiguration::add_cc_flags() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.BuildConfiguration.cc_flags)
  return cc_flags_.Add();
}
inline void BuildConfiguration::add_cc_flags(const ::std::string& value) {
  cc_flags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.BuildConfiguration.cc_flags)
}
inline void BuildConfiguration::add_cc_flags(const char* value) {
  cc_flags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.BuildConfiguration.cc_flags)
}
inline void BuildConfiguration::add_cc_flags(const char* value, size_t size) {
  cc_flags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.BuildConfiguration.cc_flags)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BuildConfiguration::cc_flags() const {
  // @@protoc_insertion_point(field_list:tensorflow.BuildConfiguration.cc_flags)
  return cc_flags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BuildConfiguration::mutable_cc_flags() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.BuildConfiguration.cc_flags)
  return &cc_flags_;
}

// repeated string opts = 3;
inline int BuildConfiguration::opts_size() const {
  return opts_.size();
}
inline void BuildConfiguration::clear_opts() {
  opts_.Clear();
}
inline const ::std::string& BuildConfiguration::opts(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.BuildConfiguration.opts)
  return opts_.Get(index);
}
inline ::std::string* BuildConfiguration::mutable_opts(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.BuildConfiguration.opts)
  return opts_.Mutable(index);
}
inline void BuildConfiguration::set_opts(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.BuildConfiguration.opts)
  opts_.Mutable(index)->assign(value);
}
inline void BuildConfiguration::set_opts(int index, const char* value) {
  opts_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.BuildConfiguration.opts)
}
inline void BuildConfiguration::set_opts(int index, const char* value, size_t size) {
  opts_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.BuildConfiguration.opts)
}
inline ::std::string* BuildConfiguration::add_opts() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.BuildConfiguration.opts)
  return opts_.Add();
}
inline void BuildConfiguration::add_opts(const ::std::string& value) {
  opts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.BuildConfiguration.opts)
}
inline void BuildConfiguration::add_opts(const char* value) {
  opts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.BuildConfiguration.opts)
}
inline void BuildConfiguration::add_opts(const char* value, size_t size) {
  opts_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.BuildConfiguration.opts)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BuildConfiguration::opts() const {
  // @@protoc_insertion_point(field_list:tensorflow.BuildConfiguration.opts)
  return opts_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BuildConfiguration::mutable_opts() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.BuildConfiguration.opts)
  return &opts_;
}

// -------------------------------------------------------------------

// CommitId

// optional int64 changelist = 1;
inline bool CommitId::has_changelist() const {
  return kind_case() == kChangelist;
}
inline void CommitId::set_has_changelist() {
  _oneof_case_[0] = kChangelist;
}
inline void CommitId::clear_changelist() {
  if (has_changelist()) {
    kind_.changelist_ = GOOGLE_LONGLONG(0);
    clear_has_kind();
  }
}
inline ::google::protobuf::int64 CommitId::changelist() const {
  // @@protoc_insertion_point(field_get:tensorflow.CommitId.changelist)
  if (has_changelist()) {
    return kind_.changelist_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void CommitId::set_changelist(::google::protobuf::int64 value) {
  if (!has_changelist()) {
    clear_kind();
    set_has_changelist();
  }
  kind_.changelist_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.CommitId.changelist)
}

// optional string hash = 2;
inline bool CommitId::has_hash() const {
  return kind_case() == kHash;
}
inline void CommitId::set_has_hash() {
  _oneof_case_[0] = kHash;
}
inline void CommitId::clear_hash() {
  if (has_hash()) {
    kind_.hash_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_kind();
  }
}
inline const ::std::string& CommitId::hash() const {
  // @@protoc_insertion_point(field_get:tensorflow.CommitId.hash)
  if (has_hash()) {
    return kind_.hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void CommitId::set_hash(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.CommitId.hash)
  if (!has_hash()) {
    clear_kind();
    set_has_hash();
    kind_.hash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  kind_.hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.CommitId.hash)
}
inline void CommitId::set_hash(const char* value) {
  if (!has_hash()) {
    clear_kind();
    set_has_hash();
    kind_.hash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  kind_.hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.CommitId.hash)
}
inline void CommitId::set_hash(const char* value, size_t size) {
  if (!has_hash()) {
    clear_kind();
    set_has_hash();
    kind_.hash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  kind_.hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.CommitId.hash)
}
inline ::std::string* CommitId::mutable_hash() {
  if (!has_hash()) {
    clear_kind();
    set_has_hash();
    kind_.hash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.CommitId.hash)
  return kind_.hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CommitId::release_hash() {
  // @@protoc_insertion_point(field_release:tensorflow.CommitId.hash)
  if (has_hash()) {
    clear_has_kind();
    return kind_.hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void CommitId::set_allocated_hash(::std::string* hash) {
  if (!has_hash()) {
    kind_.hash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_kind();
  if (hash != NULL) {
    set_has_hash();
    kind_.hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        hash);
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CommitId.hash)
}

// optional string snapshot = 3;
inline void CommitId::clear_snapshot() {
  snapshot_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CommitId::snapshot() const {
  // @@protoc_insertion_point(field_get:tensorflow.CommitId.snapshot)
  return snapshot_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CommitId::set_snapshot(const ::std::string& value) {
  
  snapshot_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.CommitId.snapshot)
}
inline void CommitId::set_snapshot(const char* value) {
  
  snapshot_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.CommitId.snapshot)
}
inline void CommitId::set_snapshot(const char* value, size_t size) {
  
  snapshot_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.CommitId.snapshot)
}
inline ::std::string* CommitId::mutable_snapshot() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.CommitId.snapshot)
  return snapshot_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CommitId::release_snapshot() {
  // @@protoc_insertion_point(field_release:tensorflow.CommitId.snapshot)
  
  return snapshot_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CommitId::set_allocated_snapshot(::std::string* snapshot) {
  if (snapshot != NULL) {
    
  } else {
    
  }
  snapshot_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), snapshot);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CommitId.snapshot)
}

inline bool CommitId::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void CommitId::clear_has_kind() {
  _oneof_case_[0] = KIND_NOT_SET;
}
inline CommitId::KindCase CommitId::kind_case() const {
  return CommitId::KindCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CPUInfo

// optional int64 num_cores = 1;
inline void CPUInfo::clear_num_cores() {
  num_cores_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CPUInfo::num_cores() const {
  // @@protoc_insertion_point(field_get:tensorflow.CPUInfo.num_cores)
  return num_cores_;
}
inline void CPUInfo::set_num_cores(::google::protobuf::int64 value) {
  
  num_cores_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.CPUInfo.num_cores)
}

// optional int64 num_cores_allowed = 2;
inline void CPUInfo::clear_num_cores_allowed() {
  num_cores_allowed_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CPUInfo::num_cores_allowed() const {
  // @@protoc_insertion_point(field_get:tensorflow.CPUInfo.num_cores_allowed)
  return num_cores_allowed_;
}
inline void CPUInfo::set_num_cores_allowed(::google::protobuf::int64 value) {
  
  num_cores_allowed_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.CPUInfo.num_cores_allowed)
}

// optional double mhz_per_cpu = 3;
inline void CPUInfo::clear_mhz_per_cpu() {
  mhz_per_cpu_ = 0;
}
inline double CPUInfo::mhz_per_cpu() const {
  // @@protoc_insertion_point(field_get:tensorflow.CPUInfo.mhz_per_cpu)
  return mhz_per_cpu_;
}
inline void CPUInfo::set_mhz_per_cpu(double value) {
  
  mhz_per_cpu_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.CPUInfo.mhz_per_cpu)
}

// optional string cpu_info = 4;
inline void CPUInfo::clear_cpu_info() {
  cpu_info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CPUInfo::cpu_info() const {
  // @@protoc_insertion_point(field_get:tensorflow.CPUInfo.cpu_info)
  return cpu_info_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CPUInfo::set_cpu_info(const ::std::string& value) {
  
  cpu_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.CPUInfo.cpu_info)
}
inline void CPUInfo::set_cpu_info(const char* value) {
  
  cpu_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.CPUInfo.cpu_info)
}
inline void CPUInfo::set_cpu_info(const char* value, size_t size) {
  
  cpu_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.CPUInfo.cpu_info)
}
inline ::std::string* CPUInfo::mutable_cpu_info() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.CPUInfo.cpu_info)
  return cpu_info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CPUInfo::release_cpu_info() {
  // @@protoc_insertion_point(field_release:tensorflow.CPUInfo.cpu_info)
  
  return cpu_info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CPUInfo::set_allocated_cpu_info(::std::string* cpu_info) {
  if (cpu_info != NULL) {
    
  } else {
    
  }
  cpu_info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cpu_info);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CPUInfo.cpu_info)
}

// optional string cpu_governor = 5;
inline void CPUInfo::clear_cpu_governor() {
  cpu_governor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CPUInfo::cpu_governor() const {
  // @@protoc_insertion_point(field_get:tensorflow.CPUInfo.cpu_governor)
  return cpu_governor_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CPUInfo::set_cpu_governor(const ::std::string& value) {
  
  cpu_governor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.CPUInfo.cpu_governor)
}
inline void CPUInfo::set_cpu_governor(const char* value) {
  
  cpu_governor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.CPUInfo.cpu_governor)
}
inline void CPUInfo::set_cpu_governor(const char* value, size_t size) {
  
  cpu_governor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.CPUInfo.cpu_governor)
}
inline ::std::string* CPUInfo::mutable_cpu_governor() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.CPUInfo.cpu_governor)
  return cpu_governor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CPUInfo::release_cpu_governor() {
  // @@protoc_insertion_point(field_release:tensorflow.CPUInfo.cpu_governor)
  
  return cpu_governor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CPUInfo::set_allocated_cpu_governor(::std::string* cpu_governor) {
  if (cpu_governor != NULL) {
    
  } else {
    
  }
  cpu_governor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cpu_governor);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CPUInfo.cpu_governor)
}

// map<string, int64> cache_size = 6;
inline int CPUInfo::cache_size_size() const {
  return cache_size_.size();
}
inline void CPUInfo::clear_cache_size() {
  cache_size_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >&
CPUInfo::cache_size() const {
  // @@protoc_insertion_point(field_map:tensorflow.CPUInfo.cache_size)
  return cache_size_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >*
CPUInfo::mutable_cache_size() {
  // @@protoc_insertion_point(field_mutable_map:tensorflow.CPUInfo.cache_size)
  return cache_size_.MutableMap();
}

// -------------------------------------------------------------------

// MemoryInfo

// optional int64 total = 1;
inline void MemoryInfo::clear_total() {
  total_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 MemoryInfo::total() const {
  // @@protoc_insertion_point(field_get:tensorflow.MemoryInfo.total)
  return total_;
}
inline void MemoryInfo::set_total(::google::protobuf::int64 value) {
  
  total_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.MemoryInfo.total)
}

// optional int64 available = 2;
inline void MemoryInfo::clear_available() {
  available_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 MemoryInfo::available() const {
  // @@protoc_insertion_point(field_get:tensorflow.MemoryInfo.available)
  return available_;
}
inline void MemoryInfo::set_available(::google::protobuf::int64 value) {
  
  available_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.MemoryInfo.available)
}

// -------------------------------------------------------------------

// GPUInfo

// optional string model = 1;
inline void GPUInfo::clear_model() {
  model_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GPUInfo::model() const {
  // @@protoc_insertion_point(field_get:tensorflow.GPUInfo.model)
  return model_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GPUInfo::set_model(const ::std::string& value) {
  
  model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.GPUInfo.model)
}
inline void GPUInfo::set_model(const char* value) {
  
  model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.GPUInfo.model)
}
inline void GPUInfo::set_model(const char* value, size_t size) {
  
  model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.GPUInfo.model)
}
inline ::std::string* GPUInfo::mutable_model() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.GPUInfo.model)
  return model_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GPUInfo::release_model() {
  // @@protoc_insertion_point(field_release:tensorflow.GPUInfo.model)
  
  return model_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GPUInfo::set_allocated_model(::std::string* model) {
  if (model != NULL) {
    
  } else {
    
  }
  model_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.GPUInfo.model)
}

// optional string uuid = 2;
inline void GPUInfo::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GPUInfo::uuid() const {
  // @@protoc_insertion_point(field_get:tensorflow.GPUInfo.uuid)
  return uuid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GPUInfo::set_uuid(const ::std::string& value) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.GPUInfo.uuid)
}
inline void GPUInfo::set_uuid(const char* value) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.GPUInfo.uuid)
}
inline void GPUInfo::set_uuid(const char* value, size_t size) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.GPUInfo.uuid)
}
inline ::std::string* GPUInfo::mutable_uuid() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.GPUInfo.uuid)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GPUInfo::release_uuid() {
  // @@protoc_insertion_point(field_release:tensorflow.GPUInfo.uuid)
  
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GPUInfo::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    
  } else {
    
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.GPUInfo.uuid)
}

// optional string bus_id = 3;
inline void GPUInfo::clear_bus_id() {
  bus_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GPUInfo::bus_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.GPUInfo.bus_id)
  return bus_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GPUInfo::set_bus_id(const ::std::string& value) {
  
  bus_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.GPUInfo.bus_id)
}
inline void GPUInfo::set_bus_id(const char* value) {
  
  bus_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.GPUInfo.bus_id)
}
inline void GPUInfo::set_bus_id(const char* value, size_t size) {
  
  bus_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.GPUInfo.bus_id)
}
inline ::std::string* GPUInfo::mutable_bus_id() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.GPUInfo.bus_id)
  return bus_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GPUInfo::release_bus_id() {
  // @@protoc_insertion_point(field_release:tensorflow.GPUInfo.bus_id)
  
  return bus_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GPUInfo::set_allocated_bus_id(::std::string* bus_id) {
  if (bus_id != NULL) {
    
  } else {
    
  }
  bus_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bus_id);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.GPUInfo.bus_id)
}

// -------------------------------------------------------------------

// PlatformInfo

// optional string bits = 1;
inline void PlatformInfo::clear_bits() {
  bits_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlatformInfo::bits() const {
  // @@protoc_insertion_point(field_get:tensorflow.PlatformInfo.bits)
  return bits_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlatformInfo::set_bits(const ::std::string& value) {
  
  bits_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.PlatformInfo.bits)
}
inline void PlatformInfo::set_bits(const char* value) {
  
  bits_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.PlatformInfo.bits)
}
inline void PlatformInfo::set_bits(const char* value, size_t size) {
  
  bits_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.PlatformInfo.bits)
}
inline ::std::string* PlatformInfo::mutable_bits() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.PlatformInfo.bits)
  return bits_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlatformInfo::release_bits() {
  // @@protoc_insertion_point(field_release:tensorflow.PlatformInfo.bits)
  
  return bits_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlatformInfo::set_allocated_bits(::std::string* bits) {
  if (bits != NULL) {
    
  } else {
    
  }
  bits_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bits);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.PlatformInfo.bits)
}

// optional string linkage = 2;
inline void PlatformInfo::clear_linkage() {
  linkage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlatformInfo::linkage() const {
  // @@protoc_insertion_point(field_get:tensorflow.PlatformInfo.linkage)
  return linkage_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlatformInfo::set_linkage(const ::std::string& value) {
  
  linkage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.PlatformInfo.linkage)
}
inline void PlatformInfo::set_linkage(const char* value) {
  
  linkage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.PlatformInfo.linkage)
}
inline void PlatformInfo::set_linkage(const char* value, size_t size) {
  
  linkage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.PlatformInfo.linkage)
}
inline ::std::string* PlatformInfo::mutable_linkage() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.PlatformInfo.linkage)
  return linkage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlatformInfo::release_linkage() {
  // @@protoc_insertion_point(field_release:tensorflow.PlatformInfo.linkage)
  
  return linkage_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlatformInfo::set_allocated_linkage(::std::string* linkage) {
  if (linkage != NULL) {
    
  } else {
    
  }
  linkage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), linkage);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.PlatformInfo.linkage)
}

// optional string machine = 3;
inline void PlatformInfo::clear_machine() {
  machine_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlatformInfo::machine() const {
  // @@protoc_insertion_point(field_get:tensorflow.PlatformInfo.machine)
  return machine_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlatformInfo::set_machine(const ::std::string& value) {
  
  machine_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.PlatformInfo.machine)
}
inline void PlatformInfo::set_machine(const char* value) {
  
  machine_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.PlatformInfo.machine)
}
inline void PlatformInfo::set_machine(const char* value, size_t size) {
  
  machine_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.PlatformInfo.machine)
}
inline ::std::string* PlatformInfo::mutable_machine() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.PlatformInfo.machine)
  return machine_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlatformInfo::release_machine() {
  // @@protoc_insertion_point(field_release:tensorflow.PlatformInfo.machine)
  
  return machine_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlatformInfo::set_allocated_machine(::std::string* machine) {
  if (machine != NULL) {
    
  } else {
    
  }
  machine_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machine);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.PlatformInfo.machine)
}

// optional string release = 4;
inline void PlatformInfo::clear_release() {
  release_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlatformInfo::release() const {
  // @@protoc_insertion_point(field_get:tensorflow.PlatformInfo.release)
  return release_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlatformInfo::set_release(const ::std::string& value) {
  
  release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.PlatformInfo.release)
}
inline void PlatformInfo::set_release(const char* value) {
  
  release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.PlatformInfo.release)
}
inline void PlatformInfo::set_release(const char* value, size_t size) {
  
  release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.PlatformInfo.release)
}
inline ::std::string* PlatformInfo::mutable_release() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.PlatformInfo.release)
  return release_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlatformInfo::release_release() {
  // @@protoc_insertion_point(field_release:tensorflow.PlatformInfo.release)
  
  return release_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlatformInfo::set_allocated_release(::std::string* release) {
  if (release != NULL) {
    
  } else {
    
  }
  release_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), release);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.PlatformInfo.release)
}

// optional string system = 5;
inline void PlatformInfo::clear_system() {
  system_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlatformInfo::system() const {
  // @@protoc_insertion_point(field_get:tensorflow.PlatformInfo.system)
  return system_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlatformInfo::set_system(const ::std::string& value) {
  
  system_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.PlatformInfo.system)
}
inline void PlatformInfo::set_system(const char* value) {
  
  system_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.PlatformInfo.system)
}
inline void PlatformInfo::set_system(const char* value, size_t size) {
  
  system_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.PlatformInfo.system)
}
inline ::std::string* PlatformInfo::mutable_system() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.PlatformInfo.system)
  return system_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlatformInfo::release_system() {
  // @@protoc_insertion_point(field_release:tensorflow.PlatformInfo.system)
  
  return system_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlatformInfo::set_allocated_system(::std::string* system) {
  if (system != NULL) {
    
  } else {
    
  }
  system_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), system);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.PlatformInfo.system)
}

// optional string version = 6;
inline void PlatformInfo::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlatformInfo::version() const {
  // @@protoc_insertion_point(field_get:tensorflow.PlatformInfo.version)
  return version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlatformInfo::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.PlatformInfo.version)
}
inline void PlatformInfo::set_version(const char* value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.PlatformInfo.version)
}
inline void PlatformInfo::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.PlatformInfo.version)
}
inline ::std::string* PlatformInfo::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.PlatformInfo.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlatformInfo::release_version() {
  // @@protoc_insertion_point(field_release:tensorflow.PlatformInfo.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlatformInfo::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.PlatformInfo.version)
}

// -------------------------------------------------------------------

// AvailableDeviceInfo

// optional string name = 1;
inline void AvailableDeviceInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AvailableDeviceInfo::name() const {
  // @@protoc_insertion_point(field_get:tensorflow.AvailableDeviceInfo.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AvailableDeviceInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.AvailableDeviceInfo.name)
}
inline void AvailableDeviceInfo::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.AvailableDeviceInfo.name)
}
inline void AvailableDeviceInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.AvailableDeviceInfo.name)
}
inline ::std::string* AvailableDeviceInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.AvailableDeviceInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AvailableDeviceInfo::release_name() {
  // @@protoc_insertion_point(field_release:tensorflow.AvailableDeviceInfo.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AvailableDeviceInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.AvailableDeviceInfo.name)
}

// optional string type = 2;
inline void AvailableDeviceInfo::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AvailableDeviceInfo::type() const {
  // @@protoc_insertion_point(field_get:tensorflow.AvailableDeviceInfo.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AvailableDeviceInfo::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.AvailableDeviceInfo.type)
}
inline void AvailableDeviceInfo::set_type(const char* value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.AvailableDeviceInfo.type)
}
inline void AvailableDeviceInfo::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.AvailableDeviceInfo.type)
}
inline ::std::string* AvailableDeviceInfo::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.AvailableDeviceInfo.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AvailableDeviceInfo::release_type() {
  // @@protoc_insertion_point(field_release:tensorflow.AvailableDeviceInfo.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AvailableDeviceInfo::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.AvailableDeviceInfo.type)
}

// optional int64 memory_limit = 3;
inline void AvailableDeviceInfo::clear_memory_limit() {
  memory_limit_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AvailableDeviceInfo::memory_limit() const {
  // @@protoc_insertion_point(field_get:tensorflow.AvailableDeviceInfo.memory_limit)
  return memory_limit_;
}
inline void AvailableDeviceInfo::set_memory_limit(::google::protobuf::int64 value) {
  
  memory_limit_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.AvailableDeviceInfo.memory_limit)
}

// optional string physical_description = 4;
inline void AvailableDeviceInfo::clear_physical_description() {
  physical_description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AvailableDeviceInfo::physical_description() const {
  // @@protoc_insertion_point(field_get:tensorflow.AvailableDeviceInfo.physical_description)
  return physical_description_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AvailableDeviceInfo::set_physical_description(const ::std::string& value) {
  
  physical_description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.AvailableDeviceInfo.physical_description)
}
inline void AvailableDeviceInfo::set_physical_description(const char* value) {
  
  physical_description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.AvailableDeviceInfo.physical_description)
}
inline void AvailableDeviceInfo::set_physical_description(const char* value, size_t size) {
  
  physical_description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.AvailableDeviceInfo.physical_description)
}
inline ::std::string* AvailableDeviceInfo::mutable_physical_description() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.AvailableDeviceInfo.physical_description)
  return physical_description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AvailableDeviceInfo::release_physical_description() {
  // @@protoc_insertion_point(field_release:tensorflow.AvailableDeviceInfo.physical_description)
  
  return physical_description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AvailableDeviceInfo::set_allocated_physical_description(::std::string* physical_description) {
  if (physical_description != NULL) {
    
  } else {
    
  }
  physical_description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), physical_description);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.AvailableDeviceInfo.physical_description)
}

// -------------------------------------------------------------------

// MachineConfiguration

// optional string hostname = 1;
inline void MachineConfiguration::clear_hostname() {
  hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MachineConfiguration::hostname() const {
  // @@protoc_insertion_point(field_get:tensorflow.MachineConfiguration.hostname)
  return hostname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MachineConfiguration::set_hostname(const ::std::string& value) {
  
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.MachineConfiguration.hostname)
}
inline void MachineConfiguration::set_hostname(const char* value) {
  
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.MachineConfiguration.hostname)
}
inline void MachineConfiguration::set_hostname(const char* value, size_t size) {
  
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.MachineConfiguration.hostname)
}
inline ::std::string* MachineConfiguration::mutable_hostname() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.MachineConfiguration.hostname)
  return hostname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MachineConfiguration::release_hostname() {
  // @@protoc_insertion_point(field_release:tensorflow.MachineConfiguration.hostname)
  
  return hostname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MachineConfiguration::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    
  } else {
    
  }
  hostname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MachineConfiguration.hostname)
}

// optional string serial_identifier = 7;
inline void MachineConfiguration::clear_serial_identifier() {
  serial_identifier_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MachineConfiguration::serial_identifier() const {
  // @@protoc_insertion_point(field_get:tensorflow.MachineConfiguration.serial_identifier)
  return serial_identifier_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MachineConfiguration::set_serial_identifier(const ::std::string& value) {
  
  serial_identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.MachineConfiguration.serial_identifier)
}
inline void MachineConfiguration::set_serial_identifier(const char* value) {
  
  serial_identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.MachineConfiguration.serial_identifier)
}
inline void MachineConfiguration::set_serial_identifier(const char* value, size_t size) {
  
  serial_identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.MachineConfiguration.serial_identifier)
}
inline ::std::string* MachineConfiguration::mutable_serial_identifier() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.MachineConfiguration.serial_identifier)
  return serial_identifier_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MachineConfiguration::release_serial_identifier() {
  // @@protoc_insertion_point(field_release:tensorflow.MachineConfiguration.serial_identifier)
  
  return serial_identifier_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MachineConfiguration::set_allocated_serial_identifier(::std::string* serial_identifier) {
  if (serial_identifier != NULL) {
    
  } else {
    
  }
  serial_identifier_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_identifier);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MachineConfiguration.serial_identifier)
}

// optional .tensorflow.PlatformInfo platform_info = 2;
inline bool MachineConfiguration::has_platform_info() const {
  return !_is_default_instance_ && platform_info_ != NULL;
}
inline void MachineConfiguration::clear_platform_info() {
  if (GetArenaNoVirtual() == NULL && platform_info_ != NULL) delete platform_info_;
  platform_info_ = NULL;
}
inline const ::tensorflow::PlatformInfo& MachineConfiguration::platform_info() const {
  // @@protoc_insertion_point(field_get:tensorflow.MachineConfiguration.platform_info)
  return platform_info_ != NULL ? *platform_info_ : *default_instance_->platform_info_;
}
inline ::tensorflow::PlatformInfo* MachineConfiguration::mutable_platform_info() {
  
  if (platform_info_ == NULL) {
    platform_info_ = new ::tensorflow::PlatformInfo;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.MachineConfiguration.platform_info)
  return platform_info_;
}
inline ::tensorflow::PlatformInfo* MachineConfiguration::release_platform_info() {
  // @@protoc_insertion_point(field_release:tensorflow.MachineConfiguration.platform_info)
  
  ::tensorflow::PlatformInfo* temp = platform_info_;
  platform_info_ = NULL;
  return temp;
}
inline void MachineConfiguration::set_allocated_platform_info(::tensorflow::PlatformInfo* platform_info) {
  delete platform_info_;
  platform_info_ = platform_info;
  if (platform_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MachineConfiguration.platform_info)
}

// optional .tensorflow.CPUInfo cpu_info = 3;
inline bool MachineConfiguration::has_cpu_info() const {
  return !_is_default_instance_ && cpu_info_ != NULL;
}
inline void MachineConfiguration::clear_cpu_info() {
  if (GetArenaNoVirtual() == NULL && cpu_info_ != NULL) delete cpu_info_;
  cpu_info_ = NULL;
}
inline const ::tensorflow::CPUInfo& MachineConfiguration::cpu_info() const {
  // @@protoc_insertion_point(field_get:tensorflow.MachineConfiguration.cpu_info)
  return cpu_info_ != NULL ? *cpu_info_ : *default_instance_->cpu_info_;
}
inline ::tensorflow::CPUInfo* MachineConfiguration::mutable_cpu_info() {
  
  if (cpu_info_ == NULL) {
    cpu_info_ = new ::tensorflow::CPUInfo;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.MachineConfiguration.cpu_info)
  return cpu_info_;
}
inline ::tensorflow::CPUInfo* MachineConfiguration::release_cpu_info() {
  // @@protoc_insertion_point(field_release:tensorflow.MachineConfiguration.cpu_info)
  
  ::tensorflow::CPUInfo* temp = cpu_info_;
  cpu_info_ = NULL;
  return temp;
}
inline void MachineConfiguration::set_allocated_cpu_info(::tensorflow::CPUInfo* cpu_info) {
  delete cpu_info_;
  cpu_info_ = cpu_info;
  if (cpu_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MachineConfiguration.cpu_info)
}

// repeated .google.protobuf.Any device_info = 4;
inline int MachineConfiguration::device_info_size() const {
  return device_info_.size();
}
inline void MachineConfiguration::clear_device_info() {
  device_info_.Clear();
}
inline const ::google::protobuf::Any& MachineConfiguration::device_info(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.MachineConfiguration.device_info)
  return device_info_.Get(index);
}
inline ::google::protobuf::Any* MachineConfiguration::mutable_device_info(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.MachineConfiguration.device_info)
  return device_info_.Mutable(index);
}
inline ::google::protobuf::Any* MachineConfiguration::add_device_info() {
  // @@protoc_insertion_point(field_add:tensorflow.MachineConfiguration.device_info)
  return device_info_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
MachineConfiguration::mutable_device_info() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.MachineConfiguration.device_info)
  return &device_info_;
}
inline const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
MachineConfiguration::device_info() const {
  // @@protoc_insertion_point(field_list:tensorflow.MachineConfiguration.device_info)
  return device_info_;
}

// repeated .tensorflow.AvailableDeviceInfo available_device_info = 5;
inline int MachineConfiguration::available_device_info_size() const {
  return available_device_info_.size();
}
inline void MachineConfiguration::clear_available_device_info() {
  available_device_info_.Clear();
}
inline const ::tensorflow::AvailableDeviceInfo& MachineConfiguration::available_device_info(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.MachineConfiguration.available_device_info)
  return available_device_info_.Get(index);
}
inline ::tensorflow::AvailableDeviceInfo* MachineConfiguration::mutable_available_device_info(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.MachineConfiguration.available_device_info)
  return available_device_info_.Mutable(index);
}
inline ::tensorflow::AvailableDeviceInfo* MachineConfiguration::add_available_device_info() {
  // @@protoc_insertion_point(field_add:tensorflow.MachineConfiguration.available_device_info)
  return available_device_info_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::AvailableDeviceInfo >*
MachineConfiguration::mutable_available_device_info() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.MachineConfiguration.available_device_info)
  return &available_device_info_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::AvailableDeviceInfo >&
MachineConfiguration::available_device_info() const {
  // @@protoc_insertion_point(field_list:tensorflow.MachineConfiguration.available_device_info)
  return available_device_info_;
}

// optional .tensorflow.MemoryInfo memory_info = 6;
inline bool MachineConfiguration::has_memory_info() const {
  return !_is_default_instance_ && memory_info_ != NULL;
}
inline void MachineConfiguration::clear_memory_info() {
  if (GetArenaNoVirtual() == NULL && memory_info_ != NULL) delete memory_info_;
  memory_info_ = NULL;
}
inline const ::tensorflow::MemoryInfo& MachineConfiguration::memory_info() const {
  // @@protoc_insertion_point(field_get:tensorflow.MachineConfiguration.memory_info)
  return memory_info_ != NULL ? *memory_info_ : *default_instance_->memory_info_;
}
inline ::tensorflow::MemoryInfo* MachineConfiguration::mutable_memory_info() {
  
  if (memory_info_ == NULL) {
    memory_info_ = new ::tensorflow::MemoryInfo;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.MachineConfiguration.memory_info)
  return memory_info_;
}
inline ::tensorflow::MemoryInfo* MachineConfiguration::release_memory_info() {
  // @@protoc_insertion_point(field_release:tensorflow.MachineConfiguration.memory_info)
  
  ::tensorflow::MemoryInfo* temp = memory_info_;
  memory_info_ = NULL;
  return temp;
}
inline void MachineConfiguration::set_allocated_memory_info(::tensorflow::MemoryInfo* memory_info) {
  delete memory_info_;
  memory_info_ = memory_info;
  if (memory_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MachineConfiguration.memory_info)
}

// -------------------------------------------------------------------

// RunConfiguration

// repeated string argument = 1;
inline int RunConfiguration::argument_size() const {
  return argument_.size();
}
inline void RunConfiguration::clear_argument() {
  argument_.Clear();
}
inline const ::std::string& RunConfiguration::argument(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.RunConfiguration.argument)
  return argument_.Get(index);
}
inline ::std::string* RunConfiguration::mutable_argument(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.RunConfiguration.argument)
  return argument_.Mutable(index);
}
inline void RunConfiguration::set_argument(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.RunConfiguration.argument)
  argument_.Mutable(index)->assign(value);
}
inline void RunConfiguration::set_argument(int index, const char* value) {
  argument_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.RunConfiguration.argument)
}
inline void RunConfiguration::set_argument(int index, const char* value, size_t size) {
  argument_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.RunConfiguration.argument)
}
inline ::std::string* RunConfiguration::add_argument() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.RunConfiguration.argument)
  return argument_.Add();
}
inline void RunConfiguration::add_argument(const ::std::string& value) {
  argument_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.RunConfiguration.argument)
}
inline void RunConfiguration::add_argument(const char* value) {
  argument_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.RunConfiguration.argument)
}
inline void RunConfiguration::add_argument(const char* value, size_t size) {
  argument_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.RunConfiguration.argument)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RunConfiguration::argument() const {
  // @@protoc_insertion_point(field_list:tensorflow.RunConfiguration.argument)
  return argument_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RunConfiguration::mutable_argument() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.RunConfiguration.argument)
  return &argument_;
}

// -------------------------------------------------------------------

// TestResults

// optional string target = 1;
inline void TestResults::clear_target() {
  target_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TestResults::target() const {
  // @@protoc_insertion_point(field_get:tensorflow.TestResults.target)
  return target_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestResults::set_target(const ::std::string& value) {
  
  target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.TestResults.target)
}
inline void TestResults::set_target(const char* value) {
  
  target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.TestResults.target)
}
inline void TestResults::set_target(const char* value, size_t size) {
  
  target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.TestResults.target)
}
inline ::std::string* TestResults::mutable_target() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.TestResults.target)
  return target_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TestResults::release_target() {
  // @@protoc_insertion_point(field_release:tensorflow.TestResults.target)
  
  return target_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestResults::set_allocated_target(::std::string* target) {
  if (target != NULL) {
    
  } else {
    
  }
  target_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TestResults.target)
}

// optional .tensorflow.BenchmarkEntries entries = 2;
inline bool TestResults::has_entries() const {
  return !_is_default_instance_ && entries_ != NULL;
}
inline void TestResults::clear_entries() {
  if (GetArenaNoVirtual() == NULL && entries_ != NULL) delete entries_;
  entries_ = NULL;
}
inline const ::tensorflow::BenchmarkEntries& TestResults::entries() const {
  // @@protoc_insertion_point(field_get:tensorflow.TestResults.entries)
  return entries_ != NULL ? *entries_ : *default_instance_->entries_;
}
inline ::tensorflow::BenchmarkEntries* TestResults::mutable_entries() {
  
  if (entries_ == NULL) {
    entries_ = new ::tensorflow::BenchmarkEntries;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.TestResults.entries)
  return entries_;
}
inline ::tensorflow::BenchmarkEntries* TestResults::release_entries() {
  // @@protoc_insertion_point(field_release:tensorflow.TestResults.entries)
  
  ::tensorflow::BenchmarkEntries* temp = entries_;
  entries_ = NULL;
  return temp;
}
inline void TestResults::set_allocated_entries(::tensorflow::BenchmarkEntries* entries) {
  delete entries_;
  entries_ = entries;
  if (entries) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TestResults.entries)
}

// optional .tensorflow.BuildConfiguration build_configuration = 3;
inline bool TestResults::has_build_configuration() const {
  return !_is_default_instance_ && build_configuration_ != NULL;
}
inline void TestResults::clear_build_configuration() {
  if (GetArenaNoVirtual() == NULL && build_configuration_ != NULL) delete build_configuration_;
  build_configuration_ = NULL;
}
inline const ::tensorflow::BuildConfiguration& TestResults::build_configuration() const {
  // @@protoc_insertion_point(field_get:tensorflow.TestResults.build_configuration)
  return build_configuration_ != NULL ? *build_configuration_ : *default_instance_->build_configuration_;
}
inline ::tensorflow::BuildConfiguration* TestResults::mutable_build_configuration() {
  
  if (build_configuration_ == NULL) {
    build_configuration_ = new ::tensorflow::BuildConfiguration;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.TestResults.build_configuration)
  return build_configuration_;
}
inline ::tensorflow::BuildConfiguration* TestResults::release_build_configuration() {
  // @@protoc_insertion_point(field_release:tensorflow.TestResults.build_configuration)
  
  ::tensorflow::BuildConfiguration* temp = build_configuration_;
  build_configuration_ = NULL;
  return temp;
}
inline void TestResults::set_allocated_build_configuration(::tensorflow::BuildConfiguration* build_configuration) {
  delete build_configuration_;
  build_configuration_ = build_configuration;
  if (build_configuration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TestResults.build_configuration)
}

// optional .tensorflow.CommitId commit_id = 4;
inline bool TestResults::has_commit_id() const {
  return !_is_default_instance_ && commit_id_ != NULL;
}
inline void TestResults::clear_commit_id() {
  if (GetArenaNoVirtual() == NULL && commit_id_ != NULL) delete commit_id_;
  commit_id_ = NULL;
}
inline const ::tensorflow::CommitId& TestResults::commit_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.TestResults.commit_id)
  return commit_id_ != NULL ? *commit_id_ : *default_instance_->commit_id_;
}
inline ::tensorflow::CommitId* TestResults::mutable_commit_id() {
  
  if (commit_id_ == NULL) {
    commit_id_ = new ::tensorflow::CommitId;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.TestResults.commit_id)
  return commit_id_;
}
inline ::tensorflow::CommitId* TestResults::release_commit_id() {
  // @@protoc_insertion_point(field_release:tensorflow.TestResults.commit_id)
  
  ::tensorflow::CommitId* temp = commit_id_;
  commit_id_ = NULL;
  return temp;
}
inline void TestResults::set_allocated_commit_id(::tensorflow::CommitId* commit_id) {
  delete commit_id_;
  commit_id_ = commit_id;
  if (commit_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TestResults.commit_id)
}

// optional int64 start_time = 5;
inline void TestResults::clear_start_time() {
  start_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TestResults::start_time() const {
  // @@protoc_insertion_point(field_get:tensorflow.TestResults.start_time)
  return start_time_;
}
inline void TestResults::set_start_time(::google::protobuf::int64 value) {
  
  start_time_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.TestResults.start_time)
}

// optional double run_time = 6;
inline void TestResults::clear_run_time() {
  run_time_ = 0;
}
inline double TestResults::run_time() const {
  // @@protoc_insertion_point(field_get:tensorflow.TestResults.run_time)
  return run_time_;
}
inline void TestResults::set_run_time(double value) {
  
  run_time_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.TestResults.run_time)
}

// optional .tensorflow.MachineConfiguration machine_configuration = 7;
inline bool TestResults::has_machine_configuration() const {
  return !_is_default_instance_ && machine_configuration_ != NULL;
}
inline void TestResults::clear_machine_configuration() {
  if (GetArenaNoVirtual() == NULL && machine_configuration_ != NULL) delete machine_configuration_;
  machine_configuration_ = NULL;
}
inline const ::tensorflow::MachineConfiguration& TestResults::machine_configuration() const {
  // @@protoc_insertion_point(field_get:tensorflow.TestResults.machine_configuration)
  return machine_configuration_ != NULL ? *machine_configuration_ : *default_instance_->machine_configuration_;
}
inline ::tensorflow::MachineConfiguration* TestResults::mutable_machine_configuration() {
  
  if (machine_configuration_ == NULL) {
    machine_configuration_ = new ::tensorflow::MachineConfiguration;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.TestResults.machine_configuration)
  return machine_configuration_;
}
inline ::tensorflow::MachineConfiguration* TestResults::release_machine_configuration() {
  // @@protoc_insertion_point(field_release:tensorflow.TestResults.machine_configuration)
  
  ::tensorflow::MachineConfiguration* temp = machine_configuration_;
  machine_configuration_ = NULL;
  return temp;
}
inline void TestResults::set_allocated_machine_configuration(::tensorflow::MachineConfiguration* machine_configuration) {
  delete machine_configuration_;
  machine_configuration_ = machine_configuration;
  if (machine_configuration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TestResults.machine_configuration)
}

// optional .tensorflow.RunConfiguration run_configuration = 8;
inline bool TestResults::has_run_configuration() const {
  return !_is_default_instance_ && run_configuration_ != NULL;
}
inline void TestResults::clear_run_configuration() {
  if (GetArenaNoVirtual() == NULL && run_configuration_ != NULL) delete run_configuration_;
  run_configuration_ = NULL;
}
inline const ::tensorflow::RunConfiguration& TestResults::run_configuration() const {
  // @@protoc_insertion_point(field_get:tensorflow.TestResults.run_configuration)
  return run_configuration_ != NULL ? *run_configuration_ : *default_instance_->run_configuration_;
}
inline ::tensorflow::RunConfiguration* TestResults::mutable_run_configuration() {
  
  if (run_configuration_ == NULL) {
    run_configuration_ = new ::tensorflow::RunConfiguration;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.TestResults.run_configuration)
  return run_configuration_;
}
inline ::tensorflow::RunConfiguration* TestResults::release_run_configuration() {
  // @@protoc_insertion_point(field_release:tensorflow.TestResults.run_configuration)
  
  ::tensorflow::RunConfiguration* temp = run_configuration_;
  run_configuration_ = NULL;
  return temp;
}
inline void TestResults::set_allocated_run_configuration(::tensorflow::RunConfiguration* run_configuration) {
  delete run_configuration_;
  run_configuration_ = run_configuration;
  if (run_configuration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TestResults.run_configuration)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tensorflow

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tensorflow_2fcore_2futil_2ftest_5flog_2eproto__INCLUDED
